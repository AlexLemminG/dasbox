//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options indenting = 4\n"
"\n"
"options multiple_contexts\n"
"\n"
"module live shared public\n"
"\n"
"require daslib/rtti\n"
"require daslib/decs\n"
"require daslib/static_let\n"
"require debugapi\n"
"require fio\n"
"\n"
"var private appPtr : smart_ptr<Context>\n"
"var private appFile = \"app.das\"\n"
"var private appDir  = get_das_root() + \"/modules/dasGlfw/framework\"\n"
"var private appLive = false\n"
"\n"
"var private appTime : table<string;clock>\n"
"var private watchTime = get_clock()\n"
"\n"
"var private liveFunctionLookup : table<string; bool>\n"
"\n"
"var public decsLiveData : array<uint8>\n"
"\n"
"var private liveContext : smart_ptr<Context>\n"
"\n"
"def public get_live_context : smart_ptr<Context>\n"
"    return liveContext\n"
"\n"
"[export]\n"
"def saveLiveContext\n"
"    decsLiveData <- mem_archive_save(decsState)\n"
"\n"
"[export]\n"
"def restoreLiveContext\n"
"    if length(decsLiveData) > 0\n"
"        decsLiveData |> mem_archive_load(decsState)\n"
"\n"
"[finalize]\n"
"def private go_offline\n"
"    appPtr := null\n"
"\n"
"def public is_live\n"
"    return appLive\n"
"\n"
"def public is_app_live\n"
"    return appPtr != null\n"
"\n"
"def public go_main\n"
"    delete decsLiveData\n"
"    appLive = false\n"
"    unsafe\n"
"        var ctx <- reinterpret<smart_ptr<Context>> addr(this_context())\n"
"        appPtr := ctx\n"
"\n"
"def public go_live ( appf, appd : string )\n"
"    appLive = true\n"
"    this_context().name := \"Live context\"\n"
"    appFile = appf\n"
"    appDir = appd\n"
"    delete decsLiveData\n"
"    recompile()\n"
"\n"
"def private live_lookup(fn)\n"
"    if appPtr==null\n"
"        return false\n"
"    if !liveFunctionLookup |> key_exists(fn)\n"
"        liveFunctionLookup[fn] = *appPtr |> has_function(fn)\n"
"    return liveFunctionLookup[fn]\n"
"\n"
"def public invoke_live ( fn:string )\n"
"    if live_lookup(fn)\n"
"        try\n"
"            unsafe\n"
"                invoke_in_context(appPtr, fn)\n"
"        recover\n"
"            print(\"exception during '{fn}'\\n{appPtr.last_exception}\\n{describe(a"
"ppPtr.exceptionAt)}\\n\")\n"
"            appPtr := null\n"
"\n"
"def public invoke_live ( fn:string; a1 )\n"
"    if live_lookup(fn)\n"
"        try\n"
"            unsafe\n"
"                invoke_in_context(appPtr, fn, a1)\n"
"        recover\n"
"            print(\"exception during '{fn}'\\n{appPtr.last_exception}\\n{describe(a"
"ppPtr.exceptionAt)}\\n\")\n"
"            appPtr := null\n"
"\n"
"def public invoke_live ( fn:string; a1; a2 )\n"
"    if live_lookup(fn)\n"
"        try\n"
"            unsafe\n"
"                invoke_in_context(appPtr, fn, a1, a2)\n"
"        recover\n"
"            print(\"exception during '{fn}'\\n{appPtr.last_exception}\\n{describe(a"
"ppPtr.exceptionAt)}\\n\")\n"
"            appPtr := null\n"
"\n"
"def public invoke_live ( fn:string; a1; a2; a3 )\n"
"    if live_lookup(fn)\n"
"        try\n"
"            unsafe\n"
"                invoke_in_context(appPtr, fn, a1, a2, a3)\n"
"        recover\n"
"            print(\"exception during '{fn}'\\n{appPtr.last_exception}\\n{describe(a"
"ppPtr.exceptionAt)}\\n\")\n"
"            appPtr := null\n"
"\n"
"def public invoke_live ( fn:string; a1; a2; a3; a4 )\n"
"    if live_lookup(fn)\n"
"        try\n"
"            unsafe\n"
"                invoke_in_context(appPtr, fn, a1, a2, a3, a4)\n"
"        recover\n"
"            print(\"exception during '{fn}'\\n{appPtr.last_exception}\\n{describe(a"
"ppPtr.exceptionAt)}\\n\")\n"
"            appPtr := null\n"
"\n"
"def public watch_files\n"
"    var clk = get_clock()\n"
"    if (clk - watchTime) <= 0.\n"
"        return false\n"
"    watchTime = clk\n"
"    var any = false\n"
"    dir(appDir) <| $ (fname)\n"
"        let fileName = \"{appDir}\\/{fname}\"\n"
"        var st : FStat\n"
"        if stat(fileName,st)\n"
"            if st.is_reg\n"
"                if appTime |> key_exists(fname)\n"
"                    if appTime[fname] != st.mtime\n"
"                        any = true\n"
"                appTime[fname] = st.mtime\n"
"    return any\n"
"\n"
"[export]\n"
"def public set_new_context ( var ptr : smart_ptr<Context>; full_restart:bool = f"
"alse )\n"
"    // print(\"set new context {intptr(get_ptr(ptr))}\\n\")\n"
"    invoke_live(\"shutdown\")\n"
"    if appPtr != null\n"
"        unsafe\n"
"            // fixup decs if its there\n"
"            var pvar = get_context_global_variable(appPtr, \"decsState\")\n"
"            if pvar != null\n"
"                var pstate : array<uint8> ? = get_context_global_variable(appPtr"
", \"decsLiveData\")\n"
"                assert(pstate!=null)\n"
"                var css <- @ <|\n"
"                    saveLiveContext()\n"
"                invoke_in_context(appPtr, css)\n"
"                decsLiveData := *pstate\n"
"                delete css\n"
"    appPtr := ptr\n"
"    delete liveFunctionLookup\n"
"    if appPtr != null\n"
"        appPtr.alwaysStackWalkOnException = true\n"
"        if !full_restart\n"
"            unsafe\n"
"                // fixup decs if its there\n"
"                var pvar = get_context_global_variable(appPtr, \"decsState\")\n"
"                if pvar != null\n"
"                    var pstate : array<uint8> ? = get_context_global_variable(ap"
"pPtr, \"decsLiveData\")\n"
"                    assert(pstate!=null)\n"
"                    var css <- @ <| [[&decsState,&decsLiveData]] ( data : array<"
"uint8># )\n"
"                        decsLiveData := data\n"
"                        restoreLiveContext()\n"
"                        delete decsLiveData\n"
"                    invoke_in_context(appPtr, css, decsLiveData)\n"
"                    delete css\n"
"                // fix-up live context, if its there\n"
"                var pctx_var = get_context_global_variable(appPtr, \"liveContext\""
")\n"
"                if pctx_var != null\n"
"                    var lContext <- reinterpret<smart_ptr<Context>> addr(this_co"
"ntext())\n"
"                    var css <- @ <| [[&decsState]] ( state : DecsState? )\n"
"                        unsafe\n"
"                            liveContext <- lContext\n"
"                    invoke_in_context(appPtr, css, addr(decsState))\n"
"                    delete css\n"
"        else\n"
"            restart()\n"
"\n"
"        invoke_live(\"initialize\", full_restart)\n"
"\n"
"def public recompile(full_restart:bool=false)\n"
"    var access := make_file_access(\"\")\n"
"    using <| $(var mg:ModuleGroup#)\n"
"        using <| $(var cop:CodeOfPolicies#)\n"
"            compile_file(\"{appDir}/{appFile}\",access,addr(mg),cop) <| $(ok,progr"
"am,issues)\n"
"                if ok\n"
"                    simulate(program) <| $ ( sok; context; serrors )\n"
"                        if sok\n"
"                            // TODO: beep print(\"reloaded...\\n\")\n"
"                            set_new_context(context,full_restart)\n"
"                        else\n"
"                            print(\"{appFile} failed to simulate:\\n{issues}\\n\")\n"
"                            set_new_context([[smart_ptr<Context>]],full_restart)"
"\n"
"                else\n"
"                    print(\"{appFile} failed to compile:\\n{issues}\\n\")\n"
"                    set_new_context([[smart_ptr<Context>]],full_restart)\n"
"\n"
"def public live_keypressed ( keycode, scancode, action, mods : int )\n"
"    invoke_live(\"keypressed\", keycode, scancode, action, mods )\n"
"    if is_live()\n"
"        if scancode==19 && action==1 && mods==2\n"
"            recompile(true)\n"
"\n"
"def public live_charpressed ( charcode : uint )\n"
"    invoke_live(\"charpressed\", charcode )\n"
"\n"
"def public live_mousemoved ( x, y : double )\n"
"    invoke_live(\"mousemoved\", x, y )\n"
"\n"
"def public live_mouseenter ( yes : bool )\n"
"    invoke_live(\"mouseenter\", yes)\n"
"\n"
"def public live_mousebutton ( button, action, mods : int )\n"
"    invoke_live(\"mousebutton\", button, action, mods )\n"
"\n"
"def public live_mousescroll ( x, y : double )\n"
"    invoke_live(\"mousescroll\", x, y )\n"
"\n"
"def public live_update ( appTime : double )\n"
"    static_let <|\n"
"        var t = 0.0lf\n"
"    let dt = float(appTime - t)\n"
"    t = appTime\n"
"    invoke_live(\"act\", dt)\n"
