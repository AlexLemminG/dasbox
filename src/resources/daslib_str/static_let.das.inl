//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options indenting = 4\n"
"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options no_aot = true\n"
"\n"
"module static_let shared private\n"
"\n"
"require ast\n"
"require rtti\n"
"require daslib/ast_boost\n"
"require daslib/templates_boost\n"
"\n"
"[tag_function(static_let_tag)]\n"
"def public static_let ( blk : block ) {}\n"
"\n"
"[tag_function(static_let_tag)]\n"
"def public static_let_finalize ( blk : block ) {}\n"
"\n"
"def private make_shutdown_function ( varname:string; at:LineInfo )\n"
"    var fn <- new [[Function() at=at, atDecl=at, name:=\"shutdown`{varname}\"]]\n"
"    fn.flags |= FunctionFlags generated\n"
"    fn.flags |= FunctionFlags shutdown\n"
"    fn.result <- new [[TypeDecl() baseType=Type tVoid, at=at]]\n"
"    var blk <- new [[ExprBlock() at=at]]\n"
"    var delv <- new [[ExprDelete() at=at,\n"
"        subexpr <- new [[ExprVar() at=at, name:=varname]]\n"
"    ]]\n"
"    delv.genFlags |= ExprGenFlags alwaysSafe\n"
"    emplace(blk.list,delv)\n"
"    fn.body <- blk\n"
"    return compiling_module() |> add_function(fn)\n"
"\n"
"[tag_function_macro(tag=\"static_let_tag\")]\n"
"class StaticLetMacro : AstFunctionAnnotation\n"
"    def override transform ( var call : smart_ptr<ExprCallFunc>; var errors : da"
"s_string ) : ExpressionPtr\n"
"        assert(call.arguments[0] is ExprMakeBlock)\n"
"        var mblk = call.arguments[0] as ExprMakeBlock\n"
"        var blk = mblk._block as ExprBlock\n"
"        if blk.finalList.length != 0\n"
"            errors := \"not expecting finally section in the static_let\"\n"
"            return [[ExpressionPtr]]\n"
"        var prefix = \"`static`at_line_{int(call.at.line)}`\"\n"
"        var rules : Template\n"
"        for ex in blk.list\n"
"            if !(ex is ExprLet)\n"
"                errors := \"expecting let ... expressions in the static_let\"\n"
"                return [[ExpressionPtr]]\n"
"            var lexpr = ex as ExprLet\n"
"            for vvar in lexpr.variables\n"
"                var vclone <- clone_variable(vvar)\n"
"                vclone.flags |= VariableFlags private_variable\n"
"                vclone.flags |= VariableFlags generated\n"
"                let old_name = \"{vclone.name}\"\n"
"                let new_name = \"{prefix}{vclone.name}\"\n"
"                vclone.name := new_name\n"
"                rules |> renameVariable(old_name) <| new_name\n"
"                if !(compiling_module() |> add_variable(vclone))\n"
"                    errors := \"can't add global variable {new_name}\"\n"
"                    return [[ExpressionPtr]]\n"
"                if \"{call.name}\"==\"static_let_finalize\"\n"
"                    if !make_shutdown_function(new_name,vvar.at)\n"
"                        errors := \"can't add shutdown function {new_name}\"\n"
"                        return [[ExpressionPtr]]\n"
"        var success = true\n"
"        compiling_program() |> get_ast_context(call) <| $(valid, astc)\n"
"            if !valid\n"
"                errors := \"can't get valid program context\"\n"
"                success = false\n"
"            else\n"
"                apply_template(rules, call.at, astc.scopes[astc.scopes.length-1]"
",false)\n"
"        delete rules\n"
"        if !success\n"
"            return [[ExpressionPtr]]\n"
"        return quote <|\n"
"            pass\n"
"\n"
