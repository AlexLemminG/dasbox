//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options indenting = 4\n"
"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options no_aot = true\n"
"\n"
"module contracts shared private\n"
"\n"
"require ast\n"
"require daslib/ast_boost\n"
"\n"
"def public isYetAnotherVectorTemplate ( var td:TypeDeclPtr )\n"
"    return td.isHandle && td.annotation!=null && td.annotation.is_any_vector\n"
"\n"
"class IsAnyType : AstFunctionAnnotation\n"
"    def override apply ( var func:FunctionPtr; var group:ModuleGroup; args:Annot"
"ationArgumentList; var errors : das_string ) : bool\n"
"        if args.length != 1\n"
"            errors := \"expecting at least one argument\"\n"
"            return false\n"
"        for argv in args                    // note: N^2\n"
"            let val = get_annotation_argument_value(argv)\n"
"            if !(val is tBool)\n"
"                errors := \"invalid argument type {argv.name}\"\n"
"                return false\n"
"            var found = false\n"
"            for fna in func.arguments\n"
"                if fna.name==argv.name\n"
"                    found = true\n"
"                    break\n"
"            if !found\n"
"                errors := \"function {func.name} does not have argument {argv.nam"
"e}\"\n"
"                return false\n"
"        return true\n"
"    def override isSpecialized : bool\n"
"        return true\n"
"\n"
"[contract(name=\"expect_any_array\")]\n"
"class IsAnyArrayMacro : IsAnyType\n"
"    def override isCompatible ( var func:FunctionPtr; var types:VectorTypeDeclPt"
"r; decl:AnnotationDeclaration; var errors:das_string ) : bool\n"
"        for fna,typ in func.arguments,types // note: N^2\n"
"            for argv in decl.arguments\n"
"                if fna.name==argv.name\n"
"                    if !(typ.baseType==Type tArray || length(typ.dim)!=0 || isYe"
"tAnotherVectorTemplate(typ))\n"
"                        errors := \"argument {argv.name} is not a vector, array, "
"or [], it is {describe(typ)}\"\n"
"                        return false\n"
"        return true\n"
"\n"
"[contract(name=\"expect_any_enum\")]\n"
"class IsAnyEnumMacro : IsAnyType\n"
"    def override isCompatible ( var func:FunctionPtr; var types:VectorTypeDeclPt"
"r; decl:AnnotationDeclaration; var errors:das_string ) : bool\n"
"        for fna,typ in func.arguments,types // note: N^2\n"
"            for argv in decl.arguments\n"
"                if fna.name==argv.name\n"
"                    if length(typ.dim)!=0 || (typ.baseType!=Type tEnumeration &&"
" typ.baseType!=Type tEnumeration8 && typ.baseType!=Type tEnumeration16)\n"
"                        errors := \"argument {argv.name} is not an enumeration\"\n"
"                        return false\n"
"        return true\n"
"\n"
"[contract(name=\"expect_any_vector_type\")]\n"
"class IsAnyVectorType : IsAnyType\n"
"    def override isCompatible ( var func:FunctionPtr; var types:VectorTypeDeclPt"
"r; decl:AnnotationDeclaration; var errors:das_string ) : bool\n"
"        for fna,typ in func.arguments,types // note: N^2\n"
"            for argv in decl.arguments\n"
"                if fna.name==argv.name\n"
"                    if length(typ.dim)!=0 || !isVectorType(typ.baseType)\n"
"                        errors := \"argument {argv.name} is not a vector type (in"
"t2, float3, range, etc)\"\n"
"                        return false\n"
"        return true\n"
"\n"
"[contract(name=\"expect_any_struct\")]\n"
"class IsAnyStructMacro : IsAnyType\n"
"    def override isCompatible ( var func:FunctionPtr; var types:VectorTypeDeclPt"
"r; decl:AnnotationDeclaration; var errors:das_string ) : bool\n"
"        for fna,typ in func.arguments,types // note: N^2\n"
"            for argv in decl.arguments\n"
"                if fna.name==argv.name\n"
"                    if typ.baseType!=Type tStructure || typ.structType==null || "
"typ.structType.flags.isClass\n"
"                        errors := \"argument {argv.name} is not a structure, it i"
"s {describe(typ)}\"\n"
"                        return false\n"
"        return true\n"
"\n"
"[contract(name=\"expect_any_numeric\")]\n"
"class IsAnyNumericMacro : IsAnyType\n"
"    def override isCompatible ( var func:FunctionPtr; var types:VectorTypeDeclPt"
"r; decl:AnnotationDeclaration; var errors:das_string ) : bool\n"
"        for fna,typ in func.arguments,types // note: N^2\n"
"            for argv in decl.arguments\n"
"                if fna.name==argv.name\n"
"                    if !typ.isNumeric\n"
"                        errors := \"argument {argv.name} is not a numeric, it is "
"{describe(typ)}\"\n"
"                        return false\n"
"        return true\n"
"\n"
"[contract(name=\"expect_any_workhorse\")]\n"
"class IsAnyWorkhorse : IsAnyType\n"
"    def override isCompatible ( var func:FunctionPtr; var types:VectorTypeDeclPt"
"r; decl:AnnotationDeclaration; var errors:das_string ) : bool\n"
"        for fna,typ in func.arguments,types // note: N^2\n"
"            for argv in decl.arguments\n"
"                if fna.name==argv.name\n"
"                    if !typ.isWorkhorseType\n"
"                        errors := \"argument {argv.name} is not a workhorse type,"
" it is {describe(typ)}\"\n"
"                        return false\n"
"        return true\n"
"\n"
"[contract(name=\"expect_any_workhorse_raw\")]\n"
"class IsAnyWorkhorseNonPtrMacro : IsAnyType\n"
"    def override isCompatible ( var func:FunctionPtr; var types:VectorTypeDeclPt"
"r; decl:AnnotationDeclaration; var errors:das_string ) : bool\n"
"        for fna,typ in func.arguments,types // note: N^2\n"
"            for argv in decl.arguments\n"
"                if fna.name==argv.name\n"
"                    if !typ.isCtorType && typ.baseType!=Type tBool\n"
"                        errors := \"argument {argv.name} is not a workhorse raw t"
"ype, it is {describe(typ)}\"\n"
"                        return false\n"
"        return true\n"
"\n"
"[contract(name=\"expect_any_tuple\")]\n"
"class IsAnyTupleNonPtrMacro : IsAnyType\n"
"    def override isCompatible ( var func:FunctionPtr; var types:VectorTypeDeclPt"
"r; decl:AnnotationDeclaration; var errors:das_string ) : bool\n"
"        for fna,typ in func.arguments,types // note: N^2\n"
"            for argv in decl.arguments\n"
"                if fna.name==argv.name\n"
"                    if typ.baseType!=Type tTuple\n"
"                        errors := \"argument {argv.name} is not a tuple, it is {d"
"escribe(typ)}\"\n"
"                        return false\n"
"        return true\n"
"\n"
"[contract(name=\"expect_any_variant\")]\n"
"class IsAnyVariantNonPtrMacro : IsAnyType\n"
"    def override isCompatible ( var func:FunctionPtr; var types:VectorTypeDeclPt"
"r; decl:AnnotationDeclaration; var errors:das_string ) : bool\n"
"        for fna,typ in func.arguments,types // note: N^2\n"
"            for argv in decl.arguments\n"
"                if fna.name==argv.name\n"
"                    if typ.baseType!=Type tVariant\n"
"                        errors := \"argument {argv.name} is not a variant, it is "
"{describe(typ)}\"\n"
"                        return false\n"
"        return true\n"
"\n"
"[contract(name=\"expect_any_function\")]\n"
"class IsAnyFunctionNonPtrMacro : IsAnyType\n"
"    def override isCompatible ( var func:FunctionPtr; var types:VectorTypeDeclPt"
"r; decl:AnnotationDeclaration; var errors:das_string ) : bool\n"
"        for fna,typ in func.arguments,types // note: N^2\n"
"            for argv in decl.arguments\n"
"                if fna.name==argv.name\n"
"                    if typ.baseType!=Type tFunction\n"
"                        errors := \"argument {argv.name} is not a function, it is"
" {describe(typ)}\"\n"
"                        return false\n"
"        return true\n"
