//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options indenting = 4\n"
"options no_global_variables = false\n"
"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options persistent_heap = true\n"
"module debug shared\n"
"\n"
"require math\n"
"require strings\n"
"require rtti\n"
"require debugapi\n"
"require fio\n"
"require network\n"
"require uriparser\n"
"\n"
"require daslib/json\n"
"require daslib/json_boost\n"
"require daslib/defer\n"
"require daslib/apply_in_context\n"
"require daslib/jobque_boost\n"
"require daslib/strings_boost\n"
"require daslib/dap\n"
"\n"
"\n"
"let private\n"
"    LOCAL_VARS = 1ul\n"
"    ARGUMENT_VARS = 2ul\n"
"    GLOBAL_VARS = 3ul\n"
"    STATE_VARS = 4ul\n"
"    BLOCKS_POOL = 1000ul\n"
"\n"
"    MAX_STACK = 1000ul\n"
"    MAX_VARIABLES = 100000ul\n"
"\n"
"    print_flags_debug = (\n"
"            print_flags escapeString\n"
"        |   print_flags namesAndDimensions\n"
"        |   print_flags singleLine\n"
"        // |   print_flags humanReadable\n"
"        // |   print_flags typeQualifiers\n"
"        // |   print_flags refAddresses\n"
"    )\n"
"\n"
"def private ctx_at(var ctx: Context): DAContextAt\n"
"    unsafe\n"
"        return intptr(addr(ctx))\n"
"\n"
"def describe(ti: rtti::TypeInfo)\n"
"    unsafe\n"
"        return describe(addr(ti))\n"
"\n"
"def private get_int_arg(args: array<string>; name: string; def_val: int): int\n"
"    let idx = find_index(args, name)\n"
"    return idx >= 0 && idx + 1 < length(args) ? int(args[idx + 1]) : def_val\n"
"\n"
"def private ends_with_separator(str: string): bool\n"
"    for c in \"\\\\/\"\n"
"        if ends_with(str, to_char(c))\n"
"            return true\n"
"    return false\n"
"\n"
"def private starts_with_separator(str: string): bool\n"
"    for c in \"\\\\/\"\n"
"        if starts_with(str, to_char(c))\n"
"            return true\n"
"    return false\n"
"\n"
"def private trim_path(path: string): string\n"
"    if path == \".\"\n"
"        return \"\"\n"
"    if path |> starts_with(\"./\") || path |> starts_with(\".\\\\\")\n"
"        return path |> slice(2)\n"
"    return path\n"
"\n"
"def private join_path(a, path_b: string): string\n"
"    let b = trim_path(path_b)\n"
"    if length(a) == 0\n"
"        return fix_path(b)\n"
"    if length(b) == 0\n"
"        return fix_path(a)\n"
"    var res = build_string() <| $(builder)\n"
"        builder |> write(a)\n"
"        let ends = ends_with_separator(a)\n"
"        let starts = starts_with_separator(b)\n"
"        if ends && starts\n"
"            builder |> write(slice(b, 1))\n"
"        elif !ends && !starts\n"
"            builder |> write(\"/\")\n"
"            builder |> write(b)\n"
"        else\n"
"            builder |> write(b)\n"
"    return fix_path(res)\n"
"\n"
"def private fix_path(path: string): string\n"
"    return path |> trim_path() |> file_name_to_uri() |> normalize_uri() |> uri_t"
"o_file_name()\n"
"\n"
"def private resolve_path(path: string; paths: array<string>): string\n"
"    if path |> empty()\n"
"        return path\n"
"    for it in paths\n"
"        let newPath = it |> join_path(path)\n"
"        if stat(newPath).is_valid\n"
"            return newPath\n"
"    return fix_path(path)\n"
"\n"
"def private resolve_path(path: string; paths: array<string>; aliases: table<stri"
"ng; string>): string\n"
"    if path |> empty()\n"
"        return path\n"
"    for k, v in keys(aliases), values(aliases)\n"
"        if path |> starts_with(k)\n"
"            let fixedPath = v |> join_path <| slice(path, length(k))\n"
"            return fixedPath |> resolve_path(paths)\n"
"    return path |> resolve_path(paths)\n"
"\n"
"def private resolve_path_cache(path: string; paths: array<string>; aliases: tabl"
"e<string; string>; var cache: table<string; string>): string\n"
"    let res = cache |> find(path)\n"
"    if res != null\n"
"        return *res\n"
"    let absPath = resolve_path(path, paths, aliases)\n"
"    cache[path] = absPath\n"
"    return absPath\n"
"\n"
"def private bytes_hr(value : uint64)\n"
"    if value > uint64(1024 * 1024)\n"
"        return \"{float(value) / (1024f * 1024f)}mb ({int(value)})\"\n"
"    if value > uint64(1024)\n"
"        return \"{float(value) / 1024f}kb ({int(value)})\"\n"
"    return \"{int(value)} b\"\n"
"\n"
"\n"
"class DAWalker: DapiDataWalker\n"
"    childrenMax = 500u\n"
"    varsStack: array<DAVariable?>\n"
"    [[do_not_delete]] frame: DAStackFrame?\n"
"    visited: array<tuple<ps: void?; hash: uint>>\n"
"    inlinePreviewLimit: int = 50\n"
"\n"
"    def startWalk(var f: DAStackFrame; var v: DAVariable; cb: block<(): void>)\n"
"        unsafe\n"
"            frame = addr(f)\n"
"            varsStack |> push(addr(v))\n"
"        cb |> invoke()\n"
"        frame = null\n"
"        varsStack |> clear()\n"
"        delete visited\n"
"\n"
"    def popStack()\n"
"        let n = length(varsStack)\n"
"        if n > 1\n"
"            varsStack |> erase(n - 1)\n"
"\n"
"    def startCont()\n"
"        let n = length(varsStack)\n"
"        if varsStack[n-1].children == null\n"
"            varsStack[n-1].children = new [[array<DAVariable>]]\n"
"\n"
"    def closeCont()\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            if empty(v.value)\n"
"                v.value = v._type\n"
"\n"
"    def override canVisitStructure(ps: void?; si: StructInfo): bool\n"
"        for vis in visited\n"
"            if vis.ps == ps && vis.hash == si.hash\n"
"                return false\n"
"        return true\n"
"\n"
"    def override beforeStructure(ps: void?; si: StructInfo): void\n"
"        visited |> emplace([[auto ps, si.hash]])\n"
"\n"
"    def override beforeStructureField(ps:void?; si: StructInfo; pv: void?; vi:Va"
"rInfo; last: bool): void\n"
"        self->startCont()\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var ti = type_info(vi)\n"
"            var v & = varsStack[n - 1]\n"
"            *v.children |> emplace([[DAVariable uid=frame.varId++, name=vi.name,"
" _type=describe(ti)]])\n"
"            unsafe\n"
"                varsStack |> push(addr((*v.children)[length(*v.children) - 1]))\n"
"\n"
"    def override afterStructureField(ps:void?; si: StructInfo; pv: void?; vi:Var"
"Info; last: bool): void\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            if v.children == null\n"
"                var ti = type_info(vi)\n"
"                v.value = sprint_data(pv, ti, print_flags_debug)\n"
"            elif empty(v.value)\n"
"                v.value = v._type\n"
"        self->popStack()\n"
"\n"
"    def override afterStructure(ps: void?; si: StructInfo): void\n"
"        visited |> erase(length(visited) - 1)\n"
"        self->closeCont()\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            if v.children != null\n"
"                v.value = join_with_names(*v.children, inlinePreviewLimit)\n"
"            if empty(v.value)\n"
"                v.value = v._type\n"
"\n"
"    def override afterStructureCancel(ps: void?; si: StructInfo): void\n"
"        visited |> erase(length(visited) - 1)\n"
"        self->closeCont()\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            if v.children != null\n"
"                v.value = join_with_names(*v.children, inlinePreviewLimit)\n"
"            if empty(v.value)\n"
"                v.value = v._type\n"
"\n"
"    def override beforeArrayData(ps: void?; stride: uint; count: uint; ti:TypeIn"
"fo): void\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            v.indexedVariables = count\n"
"\n"
"    def override beforeArrayElement(ps: void?; ti: TypeInfo; pe: void?; index: u"
"int; last: bool): void\n"
"        if index >= childrenMax\n"
"            return\n"
"        self->startCont()\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            *v.children |> emplace([[DAVariable uid=frame.varId++, name=\"{int64("
"index)}\", _type=describe(ti)]])\n"
"            unsafe\n"
"                varsStack |> push(addr((*v.children)[length(*v.children) - 1]))\n"
"\n"
"    def override afterArrayElement(ps: void?; ti: TypeInfo; pe: void?; index: ui"
"nt; last: bool): void\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            if v.children == null\n"
"                unsafe\n"
"                    v.value = sprint_data(pe, addr(ti), print_flags_debug)\n"
"            elif empty(v.value)\n"
"                v.value = v._type\n"
"        self->popStack()\n"
"\n"
"    def override afterArrayData(ps: void?; stride: uint; count: uint; ti: TypeIn"
"fo): void\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            if v.children != null\n"
"                let preview = join(*v.children, inlinePreviewLimit - 5)\n"
"                if !empty(preview)\n"
"                    v.value = \"[{int64(count)}] {preview}\"\n"
"            if empty(v.value)\n"
"                v.value = \"[{int64(count)}] {v._type}\"\n"
"\n"
"    def override beforeTable(pa: DapiTable; ti: TypeInfo): void\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            v.indexedVariables = pa.size\n"
"\n"
"    def override beforeTableKey(pa: DapiTable; ti: TypeInfo; pk: void?; ki: Type"
"Info; index: uint; last: bool): void\n"
"        if index >= childrenMax\n"
"            return\n"
"        self->startCont()\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            unsafe\n"
"                *v.children |> emplace([[DAVariable uid=frame.varId++, name=spri"
"nt_data(pk, addr(ki), print_flags_debug)]])\n"
"                varsStack |> push(addr((*v.children)[length(*v.children) - 1]))\n"
"\n"
"    def override beforeTableValue(pa: DapiTable; ti: TypeInfo; pv: void?; kv: Ty"
"peInfo; index: uint; last: bool): void\n"
"        if index >= childrenMax\n"
"            return\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            v._type = describe(kv)\n"
"\n"
"    def override afterTableValue(pa: DapiTable; ti: TypeInfo; pv: void?; kv: Typ"
"eInfo; index: uint; last: bool): void\n"
"        if index >= childrenMax\n"
"            return\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            if v.children == null\n"
"                unsafe\n"
"                    v.value = sprint_data(pv, addr(kv), print_flags_debug)\n"
"            elif empty(v.value)\n"
"                v.value = v._type\n"
"        self->popStack()\n"
"\n"
"    def override afterTable(pa: DapiTable; ti: TypeInfo): void\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            if v.children != null\n"
"                let preview = join_with_names(*v.children, inlinePreviewLimit - "
"5)\n"
"                if !empty(preview)\n"
"                    v.value = \"[{int64(pa.size)}] {preview}\"\n"
"            if empty(v.value)\n"
"                v.value = \"[{int64(pa.size)}] {v._type}\"\n"
"\n"
"    tupleIndex: int = 0\n"
"    def override beforeTuple(ps: void?; ti: TypeInfo): void\n"
"        self->startCont()\n"
"        tupleIndex = 0\n"
"\n"
"    def override beforeTupleEntry(ps: void?; ti: TypeInfo; pv: void?; vi: TypeIn"
"fo; last: bool): void\n"
"        self->startCont()\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            *v.children |> emplace([[DAVariable uid=frame.varId++, name=\"{tupleI"
"ndex++}\", _type=describe(vi)]])\n"
"            unsafe\n"
"                varsStack |> push(addr((*v.children)[length(*v.children) - 1]))\n"
"\n"
"    def override afterTupleEntry(ps: void?; ti: TypeInfo; pv: void?; vi: TypeInf"
"o; last: bool): void\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            if v.children == null\n"
"                unsafe\n"
"                    v.value = sprint_data(pv, addr(vi), print_flags_debug)\n"
"            elif empty(v.value)\n"
"                v.value = v._type\n"
"        self->popStack()\n"
"\n"
"    def override afterTuple(ps: void?; ti: TypeInfo): void\n"
"        self->closeCont()\n"
"        let n = length(varsStack)\n"
"        if n > 0\n"
"            var v & = varsStack[n - 1]\n"
"            if v.children != null\n"
"                v.value = join(*v.children, inlinePreviewLimit)\n"
"            if empty(v.value)\n"
"                v.value = v._type\n"
"\n"
"struct private DAVariable\n"
"    uid: uint64\n"
"    name: string\n"
"    value: string\n"
"    _type: string\n"
"    indexedVariables: uint\n"
"    children: array<DAVariable>?\n"
"\n"
"def join_with_names(a: array<DAVariable>; limit: int): string\n"
"    return build_string() <| $(str)\n"
"        var first = true\n"
"        var len = limit\n"
"        let n = length(a)\n"
"        for child, idx in a, range(n)\n"
"            len -= length(child.name) + length(child.value) + 2\n"
"            if !first\n"
"                if len <= 3 && idx < n - 1\n"
"                    str |> write(\",..\")\n"
"                    break\n"
"                str |> write(\", \")\n"
"                len -= 2\n"
"            first = false\n"
"            str |> write(child.name)\n"
"            str |> write(\": \")\n"
"            str |> write(child.value)\n"
"\n"
"\n"
"def join(a: array<DAVariable>; limit: int): string\n"
"    return build_string <| $(str)\n"
"        var first = true\n"
"        let n = length(a)\n"
"        var len = limit\n"
"        for v, idx in a, range(n)\n"
"            len -= length(v.value)\n"
"            if !first\n"
"                if len <= 3 && idx < n - 1\n"
"                    str |> write(\",..\")\n"
"                    break\n"
"                str |> write(\", \")\n"
"                len -= 2\n"
"            first = false\n"
"            str |> write(v.value)\n"
"\n"
"\n"
"def find_child_var(val: DAVariable; id: uint64; cb: block<(res:DAVariable): void"
">)\n"
"    if val.uid == id\n"
"        cb |> invoke(val)\n"
"        return true\n"
"    if val.children != null\n"
"        for c in *val.children\n"
"            if c |> find_child_var(id, cb)\n"
"                return true\n"
"    return false\n"
"\n"
"\n"
"struct private DAStackFrame\n"
"    name: string\n"
"    path: string\n"
"    isBlock: bool = false\n"
"    spAddr: uint64 = 0ul\n"
"    line: uint = 1u\n"
"    variables: array<DAVariable>\n"
"    arguments: array<DAVariable>\n"
"    globals: array<DAVariable>\n"
"    state: array<tuple<uid: uint64; name:string; vars:array<DAVariable>>>\n"
"\n"
"    varId: uint64 = BLOCKS_POOL + 1ul\n"
"\n"
"\n"
"def find_child_var(stack: DAStackFrame; id: uint64; cb: block<(res:DAVariable): "
"void>)\n"
"    for c in stack.variables\n"
"        if c |> find_child_var(id, cb)\n"
"            return\n"
"    for c in stack.arguments\n"
"        if c |> find_child_var(id, cb)\n"
"            return\n"
"    for c in stack.globals\n"
"        if c |> find_child_var(id, cb)\n"
"            return\n"
"    for c in stack.state\n"
"        for v in c.vars\n"
"            if v |> find_child_var(id, cb)\n"
"                return\n"
"\n"
"\n"
"def find_child_var(stack: DAStackFrame; cb: block<(res:DAVariable; idx: uint64):"
" bool>): bool\n"
"    for c in stack.variables\n"
"        if cb |> invoke(c, LOCAL_VARS)\n"
"            return true\n"
"    for c in stack.arguments\n"
"        if cb |> invoke(c, ARGUMENT_VARS)\n"
"            return true\n"
"    for c in stack.globals\n"
"        if cb |> invoke(c, GLOBAL_VARS)\n"
"            return true\n"
"    for idx, c in iter_range(stack.state), stack.state\n"
"        for v in c.vars\n"
"            if cb |> invoke(v, STATE_VARS + uint64(idx))\n"
"                return true\n"
"    return false\n"
"\n"
"class private DAStackWalker: DapiStackWalker\n"
"    dataWalkerAdapter: smart_ptr<DataWalker>\n"
"    dataWalker: DAWalker?\n"
"\n"
"    [[do_not_delete]] ctx: DAContext?\n"
"    [[do_not_delete]] workingPaths: array<string>?\n"
"    [[do_not_delete]] pathAliases: table<string; string>?\n"
"    [[do_not_delete]] pathsCache: table<string; string>?\n"
"\n"
"    def DAStackWalker()\n"
"        dataWalker = new DAWalker()\n"
"        unsafe\n"
"            dataWalkerAdapter <- make_data_walker(dataWalker)\n"
"\n"
"    def operator delete\n"
"        unsafe\n"
"            delete dataWalkerAdapter\n"
"            delete dataWalker\n"
"\n"
"    def collectGlobals()\n"
"        let stackLen = length(ctx.stack)\n"
"        if stackLen == 0\n"
"            return\n"
"        for i in range(get_total_variables(*ctx.ctx))\n"
"            let vinfo & = get_variable_info(ctx.ctx, i)\n"
"            var value: void?\n"
"            unsafe\n"
"                value = get_context_global_variable(ctx.ctx, vinfo.name)\n"
"            let ti = type_info(vinfo)\n"
"\n"
"            var frame & = ctx.stack[stackLen - 1]\n"
"            var global = [[DAVariable uid=frame.varId++, name=vinfo.name, _type="
"describe(ti)]]\n"
"\n"
"            if ti != null\n"
"                dataWalker->startWalk(frame, global) <| $\n"
"                    dataWalkerAdapter |> walk_data(value, *ti)\n"
"\n"
"            if global.children == null\n"
"                global.value = sprint_data(value, ti, print_flags_debug)\n"
"            elif empty(global.value)\n"
"                global.value = global._type\n"
"\n"
"            frame.globals |> emplace(global)\n"
"\n"
"    def override onCallAOT(pp:Prologue; fileName:string#): void\n"
"        // print(\"AOT {fileName}\\n\")\n"
"        let n = length(ctx.stack)\n"
"        if n > 0\n"
"            ctx.stack[n - 1].name = \"def {pp.info.name} [AOT]\"\n"
"            ctx.stack[n - 1].path = \"{fileName}\"\n"
"\n"
"            self->collectGlobals()\n"
"\n"
"    def override onCallAt(pp:Prologue; info:FuncInfo; at:LineInfo): void\n"
"        // print(\"def {info.name} at {at}\\n\")\n"
"        let n = length(ctx.stack)\n"
"        if n > 0\n"
"            ctx.stack[n - 1].name = \"def {info.name}\"\n"
"            ctx.stack[n - 1].path = \"{at.fileInfo.name}\" |> resolve_path_cache(*"
"workingPaths, *pathAliases, *pathsCache)\n"
"            ctx.stack[n - 1].line = at.line\n"
"            self->collectGlobals()\n"
"\n"
"    def override onCall(pp:Prologue; info:FuncInfo): void\n"
"        // print(\"def {info.name}\\n\")\n"
"        let n = length(ctx.stack)\n"
"        if n > 0\n"
"            ctx.stack[n - 1].name = \"def {info.name}\"\n"
"            self->collectGlobals()\n"
"\n"
"    def override onBeforeCall(pp: Prologue; sp: void?): void\n"
"        let iblock = intptr(pp._block)\n"
"        let isBlock = (iblock & 1ul) != 0ul\n"
"        ctx.stack |> emplace([[DAStackFrame() isBlock=isBlock, spAddr=intptr(sp)"
" ]])\n"
"\n"
"    def override onVariable(inf: FuncInfo; vinfo: LocalVariableInfo; arg: void?;"
" inScope: bool): void\n"
"        if !inScope\n"
"            return\n"
"        let stackLen = length(ctx.stack)\n"
"        if stackLen > 0\n"
"            var frame & = ctx.stack[stackLen - 1]\n"
"            var ti = type_info(vinfo)\n"
"            var variable = [[DAVariable uid=frame.varId++, name=vinfo.name, _typ"
"e=describe(ti)]]\n"
"            if ti != null\n"
"                dataWalker->startWalk(frame, variable) <| $\n"
"                    dataWalkerAdapter |> walk_data(arg, *ti)\n"
"\n"
"            if variable.children == null\n"
"                let value = !inScope ? \"<uninitialized>\" : arg != null ? sprint_"
"data(arg, ti, print_flags_debug): \"<optimized>\"\n"
"                variable.value = value\n"
"            elif empty(variable.value)\n"
"                variable.value = variable._type\n"
"\n"
"            frame.variables |> emplace(variable)\n"
"\n"
"    def override onArgument (inf: FuncInfo; index: int; vinfo: VarInfo; arg: flo"
"at4)\n"
"        let stackLen = length(ctx.stack)\n"
"        if  stackLen > 0\n"
"            var frame & = ctx.stack[stackLen-1]\n"
"            let ti = type_info(vinfo)\n"
"            var variable = [[DAVariable uid=frame.varId++, name=vinfo.name, _typ"
"e=describe(ti)]]\n"
"            if ti != null\n"
"                dataWalker->startWalk(frame, variable) <| $\n"
"                    dataWalkerAdapter |> walk_data(arg, *ti)\n"
"\n"
"            if variable.children == null\n"
"                variable.value = sprint_data(arg, ti, print_flags_debug)\n"
"            elif empty(variable.value)\n"
"                variable.value = variable._type\n"
"\n"
"            frame.arguments |> emplace(variable)\n"
"\n"
"\n"
"struct private DABreakpoint\n"
"    id: uint64\n"
"    line: uint\n"
"\n"
"typedef\n"
"    DABreakpoints = table<string; array<DABreakpoint>>\n"
"    DAContextAt = uint64\n"
"\n"
"struct private DAContext\n"
"    id: uint64\n"
"    at: DAContextAt\n"
"    ctx: Context?\n"
"    stack: array<DAStackFrame>\n"
"    continueRequested: bool = false\n"
"    pauseRequested: bool = false\n"
"    stepInRequested: bool = false\n"
"    stepRequestedStack: int = 0 // stack depth\n"
"\n"
"\n"
"def private reset_debug_flags(var ctx: DAContext)\n"
"    ctx.continueRequested = false\n"
"    ctx.pauseRequested = false\n"
"    ctx.stepInRequested = false\n"
"    ctx.stepRequestedStack = 0\n"
"\n"
"\n"
"def private to_string(ctx: DAContext)\n"
"    return build_string() <| $(str)\n"
"        if ctx.ctx.category.debugger_attached\n"
"            str |> write(\"*\")\n"
"        let ctxNameLen = length(ctx.ctx.name)\n"
"        if ctxNameLen > 0\n"
"            str |> write(ctx.ctx.name)\n"
"        else\n"
"            str |> write(ctx.at)\n"
"        if int(ctx.ctx.category) > 0\n"
"            str |> write(\" \")\n"
"            str |> write(ctx.ctx.category)\n"
"        if ctxNameLen > 0\n"
"            str |> write(\" \")\n"
"            str |> write(ctx.at)\n"
"        str |> write(\" (\")\n"
"        str |> write(int64(ctx.id))\n"
"        str |> write(\")\")\n"
"\n"
"\n"
"def private compare_path(p1, p2: string)\n"
"    if p1 == p2\n"
"        return true\n"
"    return to_lower(p1) == to_lower(p2)\n"
"\n"
"class private DAgent: DapiDebugAgent\n"
"\n"
"    walkerAdapter: smart_ptr<StackWalker>\n"
"    walker: DAStackWalker?\n"
"    server: DAServer?\n"
"\n"
"    breakpoints: DABreakpoints\n"
"    breakpointId: uint64 = 1ul\n"
"\n"
"    contexts: array<DAContext>\n"
"    contextId: uint64 = 1ul\n"
"\n"
"    waitConnection: bool = true\n"
"    withInstruments: bool = false\n"
"    workingPaths: array<string>\n"
"    pathAliases: table<string; string>\n"
"    pathsCache: table<string; string>\n"
"\n"
"    collectingAgentData: bool = false\n"
"\n"
"    logStrMemory = false\n"
"    initialStrLimit = uint64(8 * 1024 * 1024)\n"
"    strLimit: uint64 = uint64(8 * 1024 * 1024)\n"
"\n"
"    def DAgent(var ctx: Context)\n"
"        waitConnection = wait_debugger()\n"
"        withInstruments = use_instruments()\n"
"\n"
"        walker = new DAStackWalker()\n"
"        unsafe\n"
"            walkerAdapter <- make_stack_walker(walker)\n"
"            walker.workingPaths = addr(workingPaths)\n"
"            walker.pathAliases = addr(pathAliases)\n"
"            walker.pathsCache = addr(pathsCache)\n"
"        self->startServer()\n"
"        self->addContext(ctx)\n"
"        self->addContext(this_context())\n"
"\n"
"    def startServer()\n"
"        let args <- get_command_line_arguments()\n"
"        let port = args |> get_int_arg(\"--das-debug-port\", 10000)\n"
"        server = new DAServer()\n"
"        server.port = port\n"
"        unsafe\n"
"            server.agent = addr(self)\n"
"        if !server->init(port)\n"
"            print(\"server failed to initialize\\n\")\n"
"            unsafe\n"
"                delete server\n"
"\n"
"    def addPath(path: string)\n"
"        if workingPaths |> find_index(path) < 0\n"
"            workingPaths |> push(path)\n"
"\n"
"    def setPaths(paths: array<string>; aliases: table<string; string>)\n"
"        workingPaths |> clear()\n"
"        pathsCache |> clear()\n"
"        for path in paths\n"
"            self->addPath(path)\n"
"\n"
"        let dasRoot = get_das_root()\n"
"        if !empty(dasRoot) && dasRoot != \".\"\n"
"            self->addPath(dasRoot |> join_path(\"daslib\"))\n"
"            self->addPath(dasRoot |> join_path(\"src/builtin\"))\n"
"\n"
"        pathAliases |> clear()\n"
"        for k, v in keys(aliases), values(aliases)\n"
"            pathAliases[k] = v\n"
"\n"
"    def override onUninstall(agent:DebugAgent?)\n"
"        if agent == thisAgent\n"
"            delete self\n"
"\n"
"    def operator delete\n"
"        unsafe\n"
"            delete walkerAdapter\n"
"            delete walker\n"
"            delete server\n"
"\n"
"    def log(msg: string)\n"
"        if server != null\n"
"            server->log(msg)\n"
"        else\n"
"            print(\"{msg}\\n\")\n"
"\n"
"    def reqPause(var ctx: DAContext)\n"
"        ctx |> reset_debug_flags()\n"
"        ctx.pauseRequested = true\n"
"\n"
"        if withInstruments\n"
"            for ctx in contexts\n"
"                if !ctx.ctx.category.debug_context\n"
"                    *ctx.ctx |> set_single_step(true)\n"
"\n"
"    def reqResume(var exclude: DAContext)\n"
"        if withInstruments\n"
"            for ctx in contexts\n"
"                if ctx.id != exclude.id && !ctx.ctx.category.debug_context\n"
"                    *ctx.ctx |> set_single_step(false)\n"
"\n"
"    def onBreakpointsChanged(ini: SetBreakpointsArguments): SetBreakpointsRespon"
"se\n"
"        let path = ini.source.path\n"
"        var res: SetBreakpointsResponse\n"
"        if key_exists(breakpoints, path)\n"
"            delete breakpoints[path]\n"
"        breakpoints |> erase(path)\n"
"        if length(ini.breakpoints) >= 0\n"
"            var breaks <- [[array<DABreakpoint>]]\n"
"            for b in ini.breakpoints\n"
"                breaks |> emplace([[DABreakpoint line=uint(b.line), id=breakpoin"
"tId ]])\n"
"                res.breakpoints |> emplace([[Breakpoint\n"
"                    verified=!withInstruments,\n"
"                    id=double(breakpointId),\n"
"                    source=ini.source,\n"
"                    line=b.line\n"
"                ]])\n"
"                breakpointId += 1ul\n"
"            breakpoints[path] <- breaks\n"
"\n"
"        if !withInstruments\n"
"            return <- res\n"
"\n"
"        for ctx in contexts\n"
"            if ctx.ctx.category.debug_context || ctx.ctx.category.debugger_tick\n"
"                continue\n"
"            *ctx.ctx |> clear_instruments()\n"
"            *ctx.ctx |> instrument_node(true) <| $(ati)\n"
"                if ati.fileInfo == null\n"
"                    return false\n"
"                let file = string(ati.fileInfo.name) |> resolve_path_cache(worki"
"ngPaths, pathAliases, pathsCache)\n"
"                for fileBr, brs in keys(breakpoints), values(breakpoints)\n"
"                    if compare_path(fileBr, file)\n"
"                        for br in brs\n"
"                            if br.line == ati.line\n"
"                                // print(\"set br at {file}: {br.line}\\n\")\n"
"                                if file == fileBr\n"
"                                    for resBr in res.breakpoints\n"
"                                        resBr.verified ||= uint(resBr.line) == b"
"r.line\n"
"                                return true\n"
"                        break\n"
"                return false\n"
"        return <- res\n"
"\n"
"    def override onInstrument(var ctx: Context; at: LineInfo): void\n"
"        self->onPause(ctx, at, \"breakpoint\", \"\")\n"
"\n"
"    def override onBreakpoint(var ctx: Context; at:LineInfo; reason, text:string"
"): void\n"
"        if reason == \"exception\"\n"
"            self->getContextDataFor(ctx) <| $(var ctxData: DAContext)\n"
"                ctxData |> reset_debug_flags()\n"
"        self->onPause(ctx, at, reason, text)\n"
"\n"
"    def onPause(var ctx: Context; at:LineInfo; reason, text: string): void\n"
"        if at.fileInfo == null\n"
"            return\n"
"        if server == null\n"
"            return\n"
"        if !waitConnection && (!server.configurationDone || !server.threadsDone)"
"\n"
"            return\n"
"        let path = \"{at.fileInfo.name}\" |> resolve_path_cache(workingPaths, path"
"Aliases, pathsCache)\n"
"        self->log(\"{ctx} `{reason}` breakpoint at {path}:{int(at.line)}\\n\")\n"
"\n"
"        self->addContext(ctx)\n"
"        self->getContextDataFor(ctx) <| $(var ctxData: DAContext)\n"
"            ctx |> set_single_step(true)\n"
"            self->sendStopped(ctx, ctxData, path, at, reason, text, -1ul)\n"
"            while !ctxData.continueRequested && !ctxData.stepInRequested && ctxD"
"ata.stepRequestedStack == 0\n"
"                tick_debugger()\n"
"            ctxData.continueRequested = false\n"
"            ctx |> set_single_step(!withInstruments || ctxData.stepInRequested |"
"| ctxData.stepRequestedStack > 0)\n"
"\n"
"    def override onSingleStep(var ctx: Context; at: LineInfo): void\n"
"        if at.fileInfo == null\n"
"            return\n"
"        if server == null\n"
"            return\n"
"\n"
"        // unsafe\n"
"            // self->log(\"{double(ctx_at(ctx))} step at {string(at.fileInfo.name"
") |> resolve_path_cache(workingPaths, pathAliases, pathsCache)}:{int(at.line)}\\n"
"\")\n"
"            // print(\"{double(ctx_at(ctx))} step at {string(at.fileInfo.name) |>"
" resolve_path_cache(workingPaths, pathAliases, pathsCache)}:{int(at.line)}\\n\")\n"
"\n"
"        if ctx.category.debugger_attached\n"
"            self->addContext(ctx)\n"
"\n"
"        if waitConnection && (!server.configurationDone || !server.threadsDone)\n"
"            if ctx.category.debugger_attached\n"
"                while !server.configurationDone || !server.threadsDone\n"
"                    tick_debugger()\n"
"            else\n"
"                self->log(\"[E] non debug context in single step {ctx.name}\")\n"
"            ctx |> set_single_step(!withInstruments)\n"
"\n"
"        self->getContextDataFor(ctx) <| $(var ctxData: DAContext)\n"
"            let file = string(at.fileInfo.name) |> resolve_path_cache(workingPat"
"hs, pathAliases, pathsCache)\n"
"            if ctxData.pauseRequested\n"
"                self->sendStopped(ctx, ctxData, file, at, \"pause\", \"\", -1ul)\n"
"                while ctxData.pauseRequested\n"
"                    tick_debugger()\n"
"                self->reqResume(ctxData)\n"
"\n"
"            if ctxData.stepInRequested\n"
"                ctxData.stepInRequested = false\n"
"                self->sendStopped(ctx, ctxData, file, at, \"step\", \"\", -1ul)\n"
"                while !ctxData.continueRequested && !ctxData.stepInRequested && "
"ctxData.stepRequestedStack == 0\n"
"                    tick_debugger()\n"
"                ctxData.continueRequested = false\n"
"\n"
"            if ctxData.stepRequestedStack > 0\n"
"                if stack_depth(*ctxData.ctx) > ctxData.stepRequestedStack\n"
"                    return\n"
"                ctxData.stepRequestedStack = 0\n"
"                self->sendStopped(ctx, ctxData, file, at, \"step\", \"\", -1ul)\n"
"                while !ctxData.continueRequested && !ctxData.stepInRequested && "
"ctxData.stepRequestedStack == 0\n"
"                    tick_debugger()\n"
"                ctxData.continueRequested = false\n"
"\n"
"            if withInstruments\n"
"                ctx |> set_single_step(ctxData.stepInRequested || ctxData.stepRe"
"questedStack > 0)\n"
"                return\n"
"            // self->log(\"search break `{file}`:{at.line} - {inBreak}\\n\")\n"
"            var i = 0\n"
"            while i < length(breakpoints)\n"
"                var fileBr: string\n"
"                for j, it in range(i + 1), keys(breakpoints)\n"
"                    if j == i\n"
"                        fileBr = it\n"
"                        break\n"
"                i += 1\n"
"                if !compare_path(fileBr, file)\n"
"                    continue\n"
"                let brs = breakpoints |> find(file)\n"
"                var brIdx = 0\n"
"                while brs != null && brIdx < length(*brs)\n"
"                    let br & = (*brs)[brIdx++]\n"
"                    // self->log(\"search break `{file}` {brs} in {file}\\n\")\n"
"                    if br.line != uint(at.line)\n"
"                        continue\n"
"                    self->sendStopped(ctx, ctxData, file, at, \"breakpoint\", \"\", "
"br.id)\n"
"\n"
"                    ctxData.continueRequested = false\n"
"                    while !ctxData.continueRequested && !ctxData.stepInRequested"
" && ctxData.stepRequestedStack == 0\n"
"                        tick_debugger()\n"
"                    ctxData.continueRequested = false\n"
"                    break\n"
"\n"
"    def nextStep(var ctx: Context; var ctxData:DAContext; path: string; at:LineI"
"nfo)\n"
"        delete ctxData.stack\n"
"        unsafe\n"
"            walker.ctx = addr(ctxData)\n"
"        walkerAdapter |> walk_stack(ctx, at)\n"
"        if length(ctxData.stack) > 0\n"
"            for i in range(1, length(ctxData.stack))\n"
"                let j = length(ctxData.stack) - 1\n"
"                let q = j - 1\n"
"                ctxData.stack[j].path = ctxData.stack[q].path\n"
"                ctxData.stack[j].line = ctxData.stack[q].line\n"
"            ctxData.stack[0].path = path\n"
"            ctxData.stack[0].line = at.line\n"
"\n"
"            if !collectingAgentData\n"
"                collectingAgentData = true\n"
"                collect_debug_agent_state(ctx)\n"
"                collectingAgentData = false\n"
"\n"
"    def override onVariable(var ctx: Context; category, name: string; info: Type"
"Info; data: void?): void\n"
"        self->getContextDataFor(ctx) <| $(var ctxData: DAContext)\n"
"            let stackLen = length(ctxData.stack)\n"
"            if  stackLen > 0\n"
"                var frame & = ctxData.stack[0]\n"
"                var variable = [[DAVariable uid=frame.varId++, name=name, _type="
"describe(info)]]\n"
"                walker.dataWalker->startWalk(frame, variable) <| $\n"
"                    walker.dataWalkerAdapter |> walk_data(data, info)\n"
"                if variable.children == null\n"
"                    unsafe\n"
"                        variable.value = sprint_data(data, addr(info), print_fla"
"gs_debug)\n"
"                if empty(variable.value)\n"
"                    variable.value = variable._type\n"
"\n"
"                for s in frame.state\n"
"                    if s.name == category\n"
"                        s.vars |> emplace(variable)\n"
"                        return\n"
"                frame.state |> emplace <| [[auto STATE_VARS+uint64(length(frame."
"state)), category, [{auto[] variable}] ]]\n"
"\n"
"    def sendStopped(var ctx: Context; var ctxData:DAContext; path: string; at:Li"
"neInfo; reason, text: string; brId: uint64)\n"
"        self->log(\"<< stopped `{reason}` at {path}:{int(at.line)}\")\n"
"\n"
"        self->nextStep(ctx, ctxData, path, at)\n"
"        server->sendStopped(ctxData, reason, text, brId)\n"
"\n"
"    def override onTick()\n"
"        if server != null\n"
"            if !server.disconnected\n"
"                server->tick()\n"
"            else\n"
"                waitConnection = false\n"
"                unsafe\n"
"                    delete server\n"
"                self->startServer()\n"
"\n"
"        var alloc = string_heap_bytes_allocated()\n"
"        if alloc > strLimit\n"
"            // string_heap_report()\n"
"            var report: string\n"
"            if logStrMemory\n"
"                report = \"STRING HEAP COLLECT: {bytes_hr(alloc)} -> \"\n"
"            unsafe\n"
"                string_heap_collect()\n"
"            alloc = string_heap_bytes_allocated()\n"
"            if logStrMemory\n"
"                print(\"dap: {report}{bytes_hr(alloc)} limit : {bytes_hr(strLimit"
")}\\n\")\n"
"            if alloc > strLimit\n"
"                strLimit *= uint64(2)\n"
"                if logStrMemory\n"
"                    print(\"dap: UP string heap limit: {bytes_hr(strLimit)}\\n\")\n"
"            elif strLimit > initialStrLimit && alloc < strLimit / uint64(2)\n"
"                strLimit = strLimit / uint64(2)\n"
"                if logStrMemory\n"
"                    print(\"dap: DOWN string heap limit: {bytes_hr(strLimit)}\\n\")"
"\n"
"\n"
"    def override onCreateContext(var ctx: Context): void\n"
"        // unsafe\n"
"        //     print(\"dap: context created {intptr(addr(ctx))} `{ctx.name}`\")\n"
"        self->addContext(ctx)\n"
"\n"
"    def override onDestroyContext(var ctx: Context): void\n"
"        // unsafe\n"
"        //     print(\"dap: context destroyed {intptr(addr(ctx))} `{ctx.name}`\")\n"
"        self->removeContext(ctx)\n"
"\n"
"    def getContextDataFor(var ctx: Context; cb: block<(var ctx: DAContext): void"
">): bool\n"
"        let at = ctx_at(ctx)\n"
"        for i in iter_range(contexts)\n"
"            if contexts[i].at == at\n"
"                cb |> invoke(contexts[i])\n"
"                return true\n"
"        return false\n"
"\n"
"    def getContextData(id: DAContextAt; cb: block<(var ctx: DAContext): void>): "
"bool\n"
"        for i in iter_range(contexts)\n"
"            if contexts[i].id == id\n"
"                cb |> invoke(contexts[i])\n"
"                return true\n"
"        return false\n"
"\n"
"    def getContextIdx(var ctx: Context): int\n"
"        var ctxAt = ctx_at(ctx)\n"
"        for idx in iter_range(contexts)\n"
"            if contexts[idx].at == ctxAt\n"
"                return idx\n"
"        return -1\n"
"\n"
"    def addContext(var ctx: Context): bool\n"
"        // unsafe\n"
"        //     print(\"dap: add context {intptr(addr(ctx))}\")\n"
"        let idx = self->getContextIdx(ctx)\n"
"        if idx >= 0\n"
"            return false\n"
"        unsafe\n"
"            contexts |> emplace([[DAContext at=ctx_at(ctx), id=contextId, ctx=ad"
"dr(ctx)]], 0)\n"
"        contextId += 1ul\n"
"        contexts |> sort <| $(a, b: DAContext)\n"
"            let aid = uint(a.ctx.category)\n"
"            let bid = uint(b.ctx.category)\n"
"            return aid > bid\n"
"        // TODO: send `threads` event\n"
"        return true\n"
"\n"
"    def removeContext(var ctx: Context): void\n"
"        let idx = self->getContextIdx(ctx)\n"
"        if idx >= 0\n"
"            self->removeContextIdx(idx)\n"
"\n"
"    def removeContextIdx(idx: int)\n"
"        delete contexts[idx]\n"
"        contexts |> erase(idx)\n"
"\n"
"class private DAServer: Server\n"
"    port: int\n"
"    [[do_not_delete]] agent: DAgent?\n"
"\n"
"    disconnected: bool = false\n"
"\n"
"    // message data\n"
"    current_string: array<uint8>\n"
"    toRead: int = 0\n"
"\n"
"    initialized: int = -1 // initialized event: ticks delay\n"
"    configurationDone: bool = false\n"
"    threadsDone: bool = false\n"
"\n"
"    def DAServer\n"
"        Server`Server(cast<Server> self)\n"
"\n"
"    def override onError(msg:string; code:int)\n"
"        print(\"[E] dap: server error:{code} - {msg}\\n\")\n"
"\n"
"    def override onConnect()\n"
"        print(\"dap: connected ::{port}\\n\")\n"
"\n"
"    def override onDisconnect()\n"
"        if length(current_string) > 0\n"
"            print(string(current_string))\n"
"            current_string |> clear()\n"
"        // print(\"disconnected\\n\")\n"
"\n"
"    def restart()\n"
"        if _server != null\n"
"            var session : smart_ptr<NetworkServer>\n"
"            self->save(session)\n"
"            gc0_save_smart_ptr(\"telnet-session\", session)\n"
"\n"
"    def override tick()\n"
"        Server`tick(self)\n"
"        if initialized > 0\n"
"            initialized -= 1\n"
"            if initialized == 0\n"
"                self->sendEvent(\"initialized\", null)\n"
"\n"
"    def override onData(message:uint8?; size:int)\n"
"        for i in range(size)\n"
"            var uch : uint8\n"
"            unsafe\n"
"                uch = message[i]\n"
"            let ch = int(uch)\n"
"            if toRead == 0\n"
"                push(current_string, uch)\n"
"                let prefix = \"Content-Length: \"\n"
"                if length(current_string) <= length(prefix)\n"
"                    continue\n"
"                if ch != '\\n'\n"
"                    continue\n"
"                var str = string(current_string)\n"
"                if str |> starts_with(prefix)\n"
"                    unsafe\n"
"                        var lenStr = chop(str, 16, length(current_string) - leng"
"th(prefix) - 2) // \\r\\n length\n"
"                        toRead = to_int(lenStr)\n"
"                        clear(current_string)\n"
"                continue\n"
"            if ch == '\\n' || ch == '\\r'\n"
"                continue\n"
"            push(current_string, uch)\n"
"            if length(current_string) < toRead\n"
"                continue\n"
"            toRead = 0\n"
"            var error : string\n"
"            var msg = json::read_json(current_string, error)\n"
"            defer <| $\n"
"                unsafe\n"
"                    delete msg\n"
"            clear(current_string)\n"
"            self->log(\">>>\\n\\n{write_json(msg)}\\n\\n\")\n"
"\n"
"            if msg.value is _object\n"
"                let seq = msg |> jon(\"seq\", 0lf)\n"
"                let typ = msg |> jos(\"type\", \"n/a\")\n"
"                if typ == \"request\"\n"
"                    let command = msg |> jos(\"command\", \"n/a\")\n"
"                    let arguments = msg |> joj(\"arguments\")\n"
"                    if command == \"initialize\"\n"
"                        self->reqInitialize(seq, command, arguments)\n"
"                    elif command == \"configurationDone\"\n"
"                        self->reqConfigurationDone(seq, command, arguments)\n"
"                    elif command == \"disconnect\"\n"
"                        self->reqDisconnect(seq, command, arguments)\n"
"                    elif command == \"terminate\"\n"
"                        self->reqTerminate(seq, command, arguments)\n"
"                    elif command == \"launch\"\n"
"                        self->reqLaunch(seq, command, arguments)\n"
"                    elif command == \"attach\"\n"
"                        self->reqAttach(seq, command, arguments)\n"
"                    elif command == \"setBreakpoints\"\n"
"                        self->reqSetBreakpoints(seq, command, arguments)\n"
"                    elif command == \"threads\"\n"
"                        self->reqThreads(seq, command, arguments)\n"
"                    elif command == \"stackTrace\"\n"
"                        self->reqStackTrace(seq, command, arguments)\n"
"                    elif command == \"scopes\"\n"
"                        self->reqScopes(seq, command, arguments)\n"
"                    elif command == \"variables\"\n"
"                        self->reqVariables(seq, command, arguments)\n"
"                    elif command == \"continue\"\n"
"                        self->reqContinue(seq, command, arguments)\n"
"                    elif command == \"pause\"\n"
"                        self->reqPause(seq, command, arguments)\n"
"                    elif command == \"stepIn\"\n"
"                        self->reqStepIn(seq, command, arguments)\n"
"                    elif command == \"next\"\n"
"                        self->reqNext(seq, command, arguments)\n"
"                    elif command == \"stepOut\"\n"
"                        self->reqStepOut(seq, command, arguments)\n"
"                    elif command == \"evaluate\"\n"
"                        self->reqEvaluate(seq, command, arguments)\n"
"                    else\n"
"                        self->log(\"[Error] unknown request message\\n{write_json("
"msg)}\\n\")\n"
"            else\n"
"                self->log(\"[Error] unknown message\\n{write_json(msg)}\\n\")\n"
"\n"
"    def reqInitialize(seq: double; command: string; arguments: JsonValue?)\n"
"        // var ini <- InitializeRequestArguments(arguments)\n"
"        // defer_delete(ini)\n"
"        var res = [[Capabilities\n"
"                                supportsConfigurationDoneRequest=true,\n"
"                                supportsRestartRequest=false,\n"
"                                supportTerminateDebuggee=true,\n"
"                                supportsTerminateRequest=true,\n"
"                                supportsExceptionOptions=false,\n"
"                                supportsExceptionFilterOptions=false\n"
"                                // supportsDelayedStackTraceLoading=true\n"
"                    ]]\n"
"        defer_delete(res)\n"
"        self->sendSuccessResponse(seq, command, JV(res))\n"
"        initialized = 100\n"
"        // self->sendEvent(\"initialized\")\n"
"\n"
"    def reqConfigurationDone(seq: double; command: string; data: JsonValue?)\n"
"        configurationDone = true\n"
"        self->sendSuccessResponse(seq, command, null)\n"
"\n"
"    def setPaths(data: JsonValue?)\n"
"        var resPaths: array<string>\n"
"        var pathAliases: table<string; string>\n"
"        defer_delete(resPaths)\n"
"        defer_delete(pathAliases)\n"
"        if data != null && data is _object\n"
"            let paths = data |> joj(\"paths\")\n"
"            if paths != null && paths is _array\n"
"                let pathsList & = paths as _array\n"
"                for it in pathsList\n"
"                    if it is _string\n"
"                        resPaths |> push(it as _string)\n"
"            let cwd = data |> jos(\"cwd\", \"\")\n"
"            if !empty(cwd)\n"
"                resPaths |> push(cwd)\n"
"            let aliases = data |> joj(\"pathAliases\")\n"
"            if aliases != null && aliases is _object\n"
"                let aliasesList & = aliases as _object\n"
"                for k, v in keys(aliasesList), values(aliasesList)\n"
"                    if v is _string\n"
"                        pathAliases[k] = v as _string\n"
"        agent->setPaths(resPaths, pathAliases)\n"
"\n"
"    def setInlinePreviewLimit(data: JsonValue?)\n"
"        let limit = data |> jon(\"inlinePreviewLimit\", double(agent.walker.dataWa"
"lker.inlinePreviewLimit))\n"
"        agent.walker.dataWalker.inlinePreviewLimit = int(limit)\n"
"\n"
"    def reqLaunch(seq: double; command: string; data: JsonValue?)\n"
"        self->setPaths(data)\n"
"        self->setInlinePreviewLimit(data)\n"
"        self->sendSuccessResponse(seq, command, null)\n"
"\n"
"    def reqAttach(seq: double; command: string; data: JsonValue?)\n"
"        self->setPaths(data)\n"
"        self->setInlinePreviewLimit(data)\n"
"        self->sendSuccessResponse(seq, command, null)\n"
"\n"
"    def reqDisconnect(seq: double; command: string; data: JsonValue?)\n"
"        // var ini = DisconnectRequest(data)\n"
"        // defer_delete(ini)\n"
"        self->sendSuccessResponse(seq, command, null)\n"
"        for ctx in agent.contexts\n"
"            ctx |> reset_debug_flags()\n"
"            ctx.continueRequested = true\n"
"        for data in values(agent.breakpoints)\n"
"            delete data\n"
"        agent.breakpoints |> clear()\n"
"        // ini.arguments.restart\n"
"        disconnected = true\n"
"\n"
"    def reqTerminate(seq: double; command: string; data: JsonValue?)\n"
"        self->sendSuccessResponse(seq, command, null)\n"
"        unsafe\n"
"            fio::exit(0)\n"
"\n"
"    def reqSetBreakpoints(seq: double; command: string; data: JsonValue?)\n"
"        var ini <- SetBreakpointsArguments(data)\n"
"        defer_delete(ini)\n"
"        var res <- agent->onBreakpointsChanged(ini)\n"
"        defer_delete(res)\n"
"        self->sendSuccessResponse(seq, command, JV(res))\n"
"\n"
"    def reqThreads(seq: double; command: string; data: JsonValue?)\n"
"        var res: ThreadsResponseBody\n"
"        defer_delete(res)\n"
"        threadsDone = true\n"
"        for ctx in agent.contexts\n"
"            res.threads |> emplace([[Thread id=double(ctx.id), name=ctx |> to_st"
"ring() ]])\n"
"        self->sendSuccessResponse(seq, command, JV(res))\n"
"\n"
"    def reqStackTrace(seq: double; command: string; data: JsonValue?)\n"
"        var ini <- StackTraceArguments(data)\n"
"        defer_delete(ini)\n"
"        var res: StackTraceResponseBody\n"
"        defer_delete(res)\n"
"        agent->getContextData(uint64(ini.threadId)) <| $(var ctxData: DAContext)"
"\n"
"            for idx, line in range(ini.levels), ctxData.stack\n"
"                res.stackFrames |> emplace([[StackFrame\n"
"                    id=double(ctxData.id * MAX_STACK + uint64(idx)),\n"
"                    name=line.name,\n"
"                    line=double(line.line),\n"
"                    column=1lf,\n"
"                    source=[[Source name=line.path, path=line.path]]\n"
"                ]])\n"
"            res.totalFrames = double(length(ctxData.stack))\n"
"        self->sendSuccessResponse(seq, command, JV(res))\n"
"\n"
"    def reqScopes(seq: double; command: string; data: JsonValue?)\n"
"        var ini <- ScopesArguments(data)\n"
"        defer_delete(ini)\n"
"        var res: ScopesResponseBody\n"
"        defer_delete(res)\n"
"        let ctxId = uint64(ini.frameId / double(MAX_STACK))\n"
"        agent->getContextData(ctxId) <| $(var ctxData: DAContext)\n"
"            let frameId = int(ini.frameId % double(MAX_STACK))\n"
"            if frameId >= 0 && frameId < length(ctxData.stack)\n"
"                var spAddr = ctxData.stack[frameId].spAddr\n"
"                var globs = 0\n"
"                var idx = frameId\n"
"                var first = true\n"
"                while idx < length(ctxData.stack)\n"
"                    let line & = ctxData.stack[idx]\n"
"                    if first || line.spAddr == spAddr\n"
"                        globs += length(line.globals)\n"
"                        if length(line.variables) > 0\n"
"                            res.scopes |> emplace([[Scope\n"
"                                name=first ? \"Locals\" : \"Locals ({line.name})\",\n"
"                                variablesReference=double((ctxId * MAX_STACK + u"
"int64(idx)) * MAX_VARIABLES + LOCAL_VARS)\n"
"                            ]])\n"
"                        if length(line.arguments) > 0\n"
"                            res.scopes |> emplace([[Scope\n"
"                                name=first ? \"Arguments\" : \"Arguments ({line.nam"
"e})\",\n"
"                                variablesReference=double((ctxId * MAX_STACK + u"
"int64(idx)) * MAX_VARIABLES + ARGUMENT_VARS)\n"
"                            ]])\n"
"                        if length(line.state) > 0\n"
"                            for i, state in iter_range(line.state), line.state\n"
"                                res.scopes |> emplace([[Scope\n"
"                                    name=state.name,\n"
"                                    variablesReference=double((ctxId * MAX_STACK"
" + uint64(idx)) * MAX_VARIABLES + STATE_VARS + uint64(i))\n"
"                                ]])\n"
"                        first = false\n"
"                    idx += 1\n"
"                if globs > 0\n"
"                    res.scopes |> emplace([[Scope\n"
"                        name=\"Globals\",\n"
"                        variablesReference=double(uint64(ini.frameId) * MAX_VARI"
"ABLES + GLOBAL_VARS)\n"
"                    ]])\n"
"        self->sendSuccessResponse(seq, command, JV(res))\n"
"\n"
"    def reqVariables(seq: double; command: string; data: JsonValue?)\n"
"        var ini <- VariablesArguments(data)\n"
"        defer_delete(ini)\n"
"        var res: VariablesResponseBody\n"
"        defer_delete(res)\n"
"        let ctxAndFrame = uint64(ini.variablesReference) / MAX_VARIABLES\n"
"        let ctxId = uint64(ctxAndFrame) / MAX_STACK\n"
"        agent->getContextData(ctxId) <| $(var ctxData: DAContext)\n"
"            let frameId = int(ctxAndFrame % MAX_STACK)\n"
"            if frameId >= 0 && frameId < length(ctxData.stack)\n"
"                let kind = uint64(ini.variablesReference) % MAX_VARIABLES\n"
"                let line & = ctxData.stack[frameId]\n"
"                if kind == LOCAL_VARS || kind == ARGUMENT_VARS || kind == GLOBAL"
"_VARS\n"
"                    let vars & = kind == LOCAL_VARS ? line.variables : kind == A"
"RGUMENT_VARS ? line.arguments : line.globals\n"
"                    let varsNum = length(vars)\n"
"                    for idx in range(ini.start < 0lf ? 0 : min(varsNum, int(ini."
"start)), ini.count < 0lf ? varsNum : min(varsNum, int(ini.start + ini.count)))\n"
"                        let v & = vars[idx]\n"
"                        let ref = v.children != null ? ctxAndFrame * MAX_VARIABL"
"ES + v.uid : 0ul\n"
"                        res.variables |> emplace([[Variable\n"
"                            name=v.name,\n"
"                            value=v.value,\n"
"                            _type=v._type,\n"
"                            indexedVariables=double(v.indexedVariables),\n"
"                            variablesReference=double(ref)\n"
"                        ]])\n"
"                elif kind >= STATE_VARS && kind <= BLOCKS_POOL\n"
"                    for state in line.state\n"
"                        if state.uid == kind\n"
"                            for v in state.vars\n"
"                                let ref = v.children != null ? ctxAndFrame * MAX"
"_VARIABLES + v.uid : 0ul\n"
"                                res.variables |> emplace([[Variable\n"
"                                    name=v.name,\n"
"                                    value=v.value,\n"
"                                    _type=v._type,\n"
"                                    indexedVariables=double(v.indexedVariables),"
"\n"
"                                    variablesReference=double(ref)\n"
"                                ]])\n"
"                            break\n"
"                else\n"
"                    line |> find_child_var(uint64(kind)) <| $(child)\n"
"                        if child.children != null\n"
"                            let varsNum = length(*child.children)\n"
"                            for idx in range(ini.start < 0lf ? 0 : min(varsNum, "
"int(ini.start)), ini.count < 0lf ? varsNum : min(varsNum, int(ini.start + ini.co"
"unt)))\n"
"                                let v & = (*child.children)[idx]\n"
"                                let ref = v.children != null ? ctxAndFrame * MAX"
"_VARIABLES + v.uid : 0ul\n"
"                                res.variables |> emplace([[Variable\n"
"                                    name=v.name,\n"
"                                    value=v.value,\n"
"                                    _type=v._type,\n"
"                                    indexedVariables=double(v.indexedVariables),"
"\n"
"                                    variablesReference=double(ref)\n"
"                                ]])\n"
"        self->sendSuccessResponse(seq, command, JV(res))\n"
"\n"
"    def reqContinue(seq: double; command: string; data: JsonValue?)\n"
"        var ini <- ContinueArguments(data)\n"
"        defer_delete(ini)\n"
"        agent->getContextData(uint64(ini.threadId)) <| $(var ctx: DAContext)\n"
"            ctx |> reset_debug_flags()\n"
"            ctx.continueRequested = true\n"
"        self->sendSuccessResponse(seq, command, null)\n"
"\n"
"    def reqPause(seq: double; command: string; data: JsonValue?)\n"
"        var ini <- PauseArguments(data)\n"
"        defer_delete(ini)\n"
"        agent->getContextData(uint64(ini.threadId)) <| $(var ctx: DAContext)\n"
"            agent->reqPause(ctx)\n"
"        self->sendSuccessResponse(seq, command, null)\n"
"\n"
"    def reqStepIn(seq: double; command: string; data: JsonValue?)\n"
"        var ini <- StepInArguments(data)\n"
"        defer_delete(ini)\n"
"        agent->getContextData(uint64(ini.threadId)) <| $(var ctx: DAContext)\n"
"            ctx |> reset_debug_flags()\n"
"            ctx.stepInRequested = true\n"
"        self->sendSuccessResponse(seq, command, null)\n"
"\n"
"    def reqNext(seq: double; command: string; data: JsonValue?)\n"
"        var ini <- NextArguments(data)\n"
"        defer_delete(ini)\n"
"        agent->getContextData(uint64(ini.threadId)) <| $(var ctx: DAContext)\n"
"            ctx |> reset_debug_flags()\n"
"            ctx.stepRequestedStack = stack_depth(*ctx.ctx)\n"
"            ctx.stepInRequested = ctx.stepRequestedStack == 0\n"
"        self->sendSuccessResponse(seq, command, null)\n"
"\n"
"    def reqStepOut(seq: double; command: string; data: JsonValue?)\n"
"        var ini <- NextArguments(data)\n"
"        defer_delete(ini)\n"
"        agent->getContextData(uint64(ini.threadId)) <| $(var ctx: DAContext)\n"
"            ctx |> reset_debug_flags()\n"
"            ctx.stepRequestedStack = max(stack_depth(*ctx.ctx) - 1, 0)\n"
"            ctx.stepInRequested = ctx.stepRequestedStack == 0\n"
"        self->sendSuccessResponse(seq, command, null)\n"
"\n"
"    def reqEvaluate(seq: double; command: string; data: JsonValue?)\n"
"        var ini <- EvaluateArguments(data)\n"
"        defer_delete(ini)\n"
"        var found = false\n"
"        let ctxId = uint64(ini.frameId / double(MAX_STACK))\n"
"        agent->getContextData(ctxId) <| $(var ctxData: DAContext)\n"
"            let frameId = int(ini.frameId % double(MAX_STACK))\n"
"            if frameId >= 0 && frameId < length(ctxData.stack)\n"
"                var spAddr = ctxData.stack[frameId].spAddr\n"
"                var idx = frameId\n"
"                var first = true\n"
"                while !found && idx < length(ctxData.stack)\n"
"                    let line & = ctxData.stack[idx]\n"
"                    if first || line.spAddr == spAddr\n"
"                        found = line |> find_child_var() <| $(child, varIdx)\n"
"                            if child.name == ini.expression\n"
"                                var res = [[EvaluateResponse\n"
"                                    result=child.value,\n"
"                                    _type=child._type,\n"
"                                    indexedVariables=double(child.indexedVariabl"
"es),\n"
"                                    variablesReference=double((ctxId * MAX_STACK"
" + uint64(idx)) * MAX_VARIABLES + varIdx)]]\n"
"                                self->sendSuccessResponse(seq, command, JV(res))"
"\n"
"                                delete res\n"
"                                return true\n"
"                            return false\n"
"                        first = false\n"
"                    idx += 1\n"
"        if !found\n"
"            self->sendSuccessResponse(seq, command, null)\n"
"\n"
"    def log(msg: string)\n"
"        // print(\"{msg}\\n\")\n"
"        if self->is_connected()\n"
"            self->sendOutput(\"console\", \"{msg}\\n\")\n"
"\n"
"    def sendOutput(category: string; output: string)\n"
"        var res = [[OutputEventBody category=category, output=output ]]\n"
"        defer_delete(res)\n"
"        self->sendRawData(JV({{\"type\"=>JV(\"event\"); \"event\"=>JV(\"output\"); \"body"
"\"=>JV(res)}}), /*log*/false)\n"
"\n"
"    def sendEvent(event: string; body: JsonValue?)\n"
"        self->sendRawData(JV({{\"type\"=>JV(\"event\"); \"event\"=>JV(event); \"body\"=>"
"body}}), /*log*/true)\n"
"\n"
"    def sendSuccessResponse(id: double; command: string; body: JsonValue?)\n"
"        self->sendRawData(JV({{\"request_seq\"=>JV(id); \"type\"=>JV(\"response\");\n"
"                                \"body\"=>body; \"command\"=>JV(command); \"success\"="
">JV(true)}}), /*log*/true)\n"
"\n"
"    // https://microsoft.github.io/language-server-protocol/specifications/speci"
"fication-current/#responseMessage\n"
"    def sendRawData(var data : JsonValue?; logData: bool)\n"
"        var msg = write_json(data)\n"
"        var packStr = \"Content-Length: {length(msg)}\\r\\n\\r\\n{msg}\"\n"
"        if logData\n"
"            self->log(\"<------\\n{packStr}\")\n"
"        // else\n"
"        //     print(\"<------\\n{packStr}\\n\")\n"
"        unsafe\n"
"            self->send(reinterpret<uint8?> packStr, length(packStr))\n"
"            delete data\n"
"\n"
"    def sendStopped(ctx: DAContext; reason, text: string; brId: uint64)\n"
"        self->sendEvent(\"stopped\", JV({{\n"
"            \"reason\"=>JV(reason);\n"
"            \"text\"=>empty(text) ? JV(null) : JV(text);\n"
"            \"threadId\"=>JV(double(ctx.id));\n"
"            \"allThreadsStopped\"=>JV(false);\n"
"            \"hitBreakpointIds\"=>brId == -1ul ? null : JV([{auto[] JV(brId)}])\n"
"        }}))\n"
"\n"
"def private tick_debugger()\n"
"    tick_debug_agent(\"~debug\")\n"
"    sleep(10u)\n"
"\n"
"[export,unused_argument(ctx)]\n"
"def private start_debug_agent(var ctx: Context)\n"
"    install_new_debug_agent(new DAgent(ctx), \"~debug\")\n"
"\n"
"[export]\n"
"def private start_agent(force:bool = false): bool\n"
"    if force || !has_debug_agent_context(\"~debug\")\n"
"        fork_debug_agent_context(@@start_debug_agent)\n"
"        print(use_instruments() ? \"dap: install debug agent (with instruments)\\n"
"\" : \"dap: install debug agent\\n\")\n"
"    else\n"
"        print(\"dap: debug agent already exists\\n\")\n"
"    set_single_step(this_context(), !use_instruments() || wait_debugger())\n"
"    return true\n"
"\n"
"\n"
"[init,export]\n"
"def private auto_start_debug()\n"
"    if (is_in_aot() && loads_itself()) || is_in_debug_agent_creation() || is_com"
"piling_macros()\n"
"        return\n"
"    this_context().category |= context_category_flags debugger_attached\n"
"    set_single_step(this_context(), !use_instruments() || wait_debugger())\n"
"    if !has_debug_agent_context(\"~debug\")\n"
"        if start_agent()\n"
"            new_thread <| @\n"
"                this_context().category &= ~context_category_flags debugger_atta"
"ched\n"
"                this_context().category |= context_category_flags debugger_tick\n"
"                set_single_step(this_context(), false)\n"
"                this_context().name := \"tick thread\"\n"
"                while !is_job_que_shutting_down()\n"
"                    tick_debugger()\n"
"\n"
"\n"
"def private use_instruments() // or stepping debugger\n"
"    let args <- get_command_line_arguments()\n"
"    return args |> find_index(\"--das-stepping-debugger\") < 0\n"
"\n"
"\n"
"def private wait_debugger(): bool\n"
"    let args <- get_command_line_arguments()\n"
"    return args |> find_index(\"--das-wait-debugger\") >= 0\n"
"\n"
"\n"
"def private loads_itself(): bool\n"
"    let args <- get_command_line_arguments()\n"
"    return length(args) >= 2 && (args[1] |> ends_with(\"daslib\\\\debug.das\") || ar"
"gs[1] |> ends_with(\"daslib/debug.das\"))\n"
