//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options indenting = 4\n"
"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options no_aot = true\n"
"\n"
"module jobque_boost shared public\n"
"\n"
"require jobque public\n"
"\n"
"require daslib/rtti\n"
"require daslib/ast\n"
"require daslib/ast_boost\n"
"require daslib/templates\n"
"\n"
"[tag_function(new_job_tag)]\n"
"def new_job ( var l : lambda )\n"
"    invoke(l)   // note, this is never called if job-que is there\n"
"\n"
"[tag_function(new_job_tag)]\n"
"def new_thread ( var l : lambda )\n"
"    invoke(l)   // note, this is never called if job-que is there\n"
"\n"
"[tag_function_macro(tag=\"new_job_tag\")]\n"
"class private NewJobMacro : AstFunctionAnnotation\n"
"    def override transform ( var call : smart_ptr<ExprCallFunc>; var errors : da"
"s_string ) : ExpressionPtr\n"
"        if !call.arguments[0] is ExprAscend\n"
"            compiling_program() |>macro_error(call.at,\"expecting lambda declarat"
"ion, ExprAscend\")\n"
"            return [[ExpressionPtr]]\n"
"        var asc = call.arguments[0] as ExprAscend\n"
"        if !asc.subexpr is ExprMakeStruct\n"
"            compiling_program() |>macro_error(call.at,\"expecting lambda declarat"
"ion, ExprMakeStruct\")\n"
"            return [[ExpressionPtr]]\n"
"        var mks = asc.subexpr as ExprMakeStruct\n"
"        if mks._type==null || mks._type.baseType!=Type tStructure\n"
"            compiling_program() |>macro_error(call.at,\"expecting lambda declarat"
"ion, not a structure\")\n"
"            return [[ExpressionPtr]]\n"
"        // clone structure type. make fields non-constant, so that they can be c"
"loned\n"
"        var stype <- clone_structure(mks._type.structType)\n"
"        stype.name := \"{stype.name}_new_job_clone\"\n"
"        var stype_ptr = get_ptr(stype)\n"
"        var sttype <- new [[TypeDecl() at=call.at, baseType=Type tStructure, str"
"uctType = stype_ptr]]\n"
"        for fld in stype.fields // TODO: verify field type here\n"
"            fld._type.flags &= ~(TypeDeclFlags constant)\n"
"            fld.flags &= ~(FieldDeclarationFlags capturedConstant)\n"
"        var pclone <- make_clone_structure(stype_ptr)\n"
"        compiling_module() |> add_function(pclone)\n"
"        compiling_module() |> add_structure(stype)\n"
"        // make an @@<function<(var L;L):void> type\n"
"        var ftype <- new [[TypeDecl() at=call.at, baseType=Type tFunction ]]\n"
"        ftype.firstType <- new [[TypeDecl() at=call.at, baseType=Type tVoid]]\n"
"        ftype.argTypes |> emplace_new <| clone_type(sttype)\n"
"        ftype.argTypes |> emplace <| sttype\n"
"        ftype.argTypes[1].flags |= TypeDeclFlags constant\n"
"        // make a new_job_invoke call\n"
"        var ncall <- new [[ExprCall() at=call.at, name:=\"{call.name}_invoke\"]]\n"
"        ncall.arguments |> emplace_new <| clone_expression(call.arguments[0])\n"
"        ncall.arguments |> emplace_new <| new [[ExprAddr() at=call.at, target:=\""
"clone\", funcType <- ftype]]\n"
"        ncall.arguments |> emplace_new <| new [[ExprConstInt() at=call.at, value"
"=int(mks._type.sizeOf)]]\n"
"        return <- ncall\n"
"\n"
"def for_each ( channel:Channel?; blk:block<(res:auto(TT)#):void> )\n"
"    while true\n"
"        let void_data = _builtin_channel_pop(channel)\n"
"        if void_data==null\n"
"            break\n"
"        unsafe\n"
"            let typed_data = reinterpret<TT?#> void_data\n"
"            invoke ( blk, *typed_data )\n"
"\n"
"def push_clone ( channel:Channel?; data : auto(TT) )\n"
"    var heap_data = new TT\n"
"    *heap_data := data\n"
"    _builtin_channel_push(channel, heap_data)\n"
"\n"
"def push ( channel:Channel?; data : auto? )\n"
"    _builtin_channel_push(channel, data)\n"
"\n"
"[template (tinfo)]\n"
"def each ( channel:Channel?; tinfo : auto(TT) )\n"
"    unsafe\n"
"        return <- generator<TT&#> () <| $ ()\n"
"            while true\n"
"                let void_data = _builtin_channel_pop(channel)\n"
"                if void_data==null\n"
"                    return false\n"
"                unsafe\n"
"                    yield * reinterpret<TT?#> void_data\n"
"            return false\n"
"\n"
