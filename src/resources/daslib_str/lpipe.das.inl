//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options indenting = 4\n"
"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options no_aot = true\n"
"\n"
"module lpipe shared private\n"
"\n"
"require ast\n"
"require rtti\n"
"require daslib/ast_boost\n"
"require daslib/templates_boost\n"
"\n"
"def lpipe_expr ( var fnCall:ExpressionPtr; var arg:ExpressionPtr ) : ExpressionP"
"tr\n"
"    if fnCall |> is_expr_like_call()\n"
"        unsafe\n"
"            var pCall = reinterpret<ExprLooksLikeCall?> fnCall\n"
"            if string(pCall.name)==\"lpipe\"  // not piping pipe into pipe\n"
"                return [[ExpressionPtr]]\n"
"            pCall.arguments |> emplace(arg)\n"
"        return fnCall\n"
"    elif fnCall is ExprVar\n"
"        var pVar = fnCall as ExprVar\n"
"        var pCall <- make_call(pVar.at, \"{pVar.name}\")\n"
"        unsafe\n"
"            delete fnCall\n"
"            var pCallFunc = reinterpret<ExprLooksLikeCall?> pCall\n"
"            pCallFunc.arguments |> emplace(arg)\n"
"        return pCall\n"
"    else\n"
"        unsafe\n"
"            delete arg\n"
"        return [[ExpressionPtr]]\n"
"\n"
"\n"
"[call_macro(name=\"lpipe\")]  // apply(expr)\n"
"class LpipeMacro : AstCallMacro\n"
"    def override visit ( prog:ProgramPtr; mod:Module?; var call:smart_ptr<ExprCa"
"llMacro> ) : ExpressionPtr\n"
"        if call.arguments.length != 1\n"
"            macro_error(prog,call.at,\"expecting lpipe(value)\")\n"
"            return [[ExpressionPtr]]\n"
"        var success = false\n"
"        compiling_program() |> get_ast_context(call) <| $(valid, astc)\n"
"            if !valid\n"
"                macro_error(prog,call.at,\"can't get valid program context\")\n"
"                return\n"
"            if astc.scopes.length<=0\n"
"                macro_error(prog,call.at,\"missing scope\")\n"
"                return\n"
"            var blk = astc.scopes[astc.scopes.length-1] as ExprBlock\n"
"            var eidx = -1\n"
"            for i,expr in range(100500),blk.list\n"
"                if expr==call\n"
"                    eidx = i\n"
"                    break\n"
"            if eidx==-1\n"
"                macro_error(prog,call.at,\"can't find lpipe in the block\")\n"
"                return\n"
"            if eidx==0\n"
"                macro_error(prog,call.at,\"can't pipe first expression in the blo"
"ck\")\n"
"                return\n"
"            let pidx = eidx - 1\n"
"            var pipe <- lpipe_expr(blk.list[pidx], clone_expression(call.argumen"
"ts[0]) )\n"
"            if pipe==null\n"
"                macro_error(prog,call.at,\"can only pipe to a function call\")\n"
"                return\n"
"            blk.list[pidx] <- pipe\n"
"            blk.list[eidx] := null\n"
"            success = true\n"
"        if !success\n"
"            return [[ExpressionPtr]]\n"
"        return quote <|\n"
"            pass\n"
