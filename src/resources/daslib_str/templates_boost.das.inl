//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options indenting = 4\n"
"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options no_aot = true\n"
"\n"
"module templates_boost shared public\n"
"\n"
"require ast\n"
"require daslib/ast_boost\n"
"\n"
"struct Template\n"
"    var2expr : table<string; smart_ptr<Expression>>\n"
"    type2type : table<string; string>\n"
"    blockArgName : table<string; string>\n"
"    annArg : table<string; lambda<(var ann: AnnotationDeclaration):void> >\n"
"\n"
"def replaceVariable ( var self:Template; name:string; var expr : smart_ptr<ast::"
"Expression> )\n"
"    self.var2expr[name] <- expr\n"
"\n"
"def renameVariable ( var self:Template; name, newName:string )\n"
"    self |> replaceVariable(name) <| ExpressionPtr(new [[ExprVar() name:=newName"
"]])\n"
"\n"
"def replaceType ( var self:Template; name,newName:string )\n"
"    self.type2type[name] = newName\n"
"\n"
"def replaceAnnotationArgument ( var self:Template; name:string; var cb:lambda<(v"
"ar ann: AnnotationDeclaration):void> )\n"
"    self.annArg[name] <- cb\n"
"\n"
"def replaceBlockArgument ( var self:Template; name,newName:string )\n"
"    self.blockArgName[name] = newName\n"
"\n"
"class private TemplateVisitor : AstVisitor\n"
"    rules : Template?\n"
"    def TemplateVisitor ( r : Template? )\n"
"        rules = r\n"
"    def override visitExprVar(expr:smart_ptr<ExprVar>) : ExpressionPtr\n"
"        let vn = \"{expr.name}\"\n"
"        if key_exists(rules.var2expr,vn)\n"
"            var rexpr <- clone_expression(rules.var2expr[vn])\n"
"            rexpr.at = expr.at\n"
"            return rexpr\n"
"        return expr\n"
"    def replaceAlias ( var typ:TypeDeclPtr )\n"
"        if typ.baseType==Type alias\n"
"            let ta = string(typ.alias)\n"
"            if key_exists(rules.type2type, ta)\n"
"                typ.alias := rules.type2type[ta]\n"
"        if typ.firstType != null\n"
"            self->replaceAlias(typ.firstType)\n"
"        if typ.secondType != null\n"
"            self->replaceAlias(typ.secondType)\n"
"        for arg in typ.argTypes\n"
"            self->replaceAlias(arg)\n"
"    def override visitTypeDecl(var typ:TypeDeclPtr) : TypeDeclPtr\n"
"        var tyyp <- clone_type(typ)\n"
"        self->replaceAlias(tyyp)\n"
"        return tyyp\n"
"    def override preVisitExprBlock(var blk:smart_ptr<ExprBlock>)\n"
"        if !blk.blockFlags.isClosure\n"
"            return\n"
"        for arg in blk.arguments\n"
"            let vn = \"{arg.name}\"\n"
"            if key_exists(rules.blockArgName, vn)\n"
"                arg.name := rules.blockArgName[vn]\n"
"        for ann in blk.annotations\n"
"            rules.annArg |> find_if_exists(\"{ann.annotation.name}\") <| $(cb)\n"
"                (*cb) |> invoke(*ann)\n"
"\n"
"\n"
"def apply_template ( var rules:Template; at:LineInfo; var expr:smart_ptr<Express"
"ion>; forceAt:bool = true )\n"
"    var prules : Template?\n"
"    unsafe\n"
"        prules = addr(rules)\n"
"    var astVisitor = new TemplateVisitor(prules)\n"
"    var astVisitorAdapter <- make_visitor(*astVisitor)\n"
"    expr |> visit(astVisitorAdapter)\n"
"    if forceAt\n"
"        expr |> force_at(at)\n"
"    unsafe\n"
"        delete astVisitor\n"
"    astVisitorAdapter := null\n"
"\n"
"def unquote_block ( expr:ExpressionPtr ) : smart_ptr<ExprBlock>\n"
"    assert(expr is ExprMakeBlock)\n"
"    unsafe\n"
"        var mkb <- reinterpret<smart_ptr<ExprMakeBlock>>(expr)\n"
"        var blk := mkb._block\n"
"        return reinterpret<smart_ptr<ExprBlock>>(blk)\n"
"\n"
"def move_unquote_block ( var expr:ExpressionPtr& ) : smart_ptr<ExprBlock>\n"
"    assert(expr is ExprMakeBlock)\n"
"    unsafe\n"
"        var mkb <- reinterpret<smart_ptr<ExprMakeBlock>>(expr)\n"
"        var blk := mkb._block\n"
"        var res <- reinterpret<smart_ptr<ExprBlock>>(blk)\n"
"        mkb := null\n"
"        return res\n"
"\n"
"def private add_global_var_any ( mod:Module?; vname:string; vat:LineInfo; vflag:"
"TypeDeclFlags; var value:ExpressionPtr; priv:bool )\n"
"    var vvar <- new [[Variable() at=vat,\n"
"        name:=vname,\n"
"        _type <- new [[TypeDecl() at=vat,\n"
"            baseType = Type autoinfer,\n"
"            flags = vflag\n"
"        ]],\n"
"        init <- value\n"
"    ]]\n"
"    vvar.flags |= VariableFlags generated\n"
"    if priv\n"
"        vvar.flags |= VariableFlags private_variable\n"
"    return add_variable(mod, vvar)\n"
"\n"
"def add_global_var ( mod:Module?; vname:string; vat:LineInfo; var value:Expressi"
"onPtr )\n"
"    return add_global_var_any(mod, vname, vat, TypeDeclFlags removeConstant, val"
"ue, false)\n"
"\n"
"def add_global_var ( mod:Module?; vname:string; var typ:TypeDeclPtr; vat:LineInf"
"o; priv:bool; blk:block<(var v : VariablePtr):void> )\n"
"    var vvar <- new [[Variable() at=vat,\n"
"        name:=vname,\n"
"        _type <- typ\n"
"    ]]\n"
"    vvar.flags |= VariableFlags generated\n"
"    if priv\n"
"        vvar.flags |= VariableFlags private_variable\n"
"    invoke(blk, vvar)\n"
"    return add_variable(mod, vvar)\n"
"\n"
"def add_global_var ( mod:Module?; vname:string; var typ:TypeDeclPtr; vat:LineInf"
"o; priv:bool )\n"
"    return add_global_var(mod,vname,typ,vat,priv) <| $ [unused_argument(v)]( var"
" v )\n"
"        pass\n"
"\n"
"def add_global_let ( mod:Module?; vname:string; vat:LineInfo; var value:Expressi"
"onPtr )\n"
"    return add_global_var_any(mod, vname, vat, TypeDeclFlags constant, value, fa"
"lse)\n"
"\n"
"def add_global_private_var ( mod:Module?; vname:string; vat:LineInfo; var value:"
"ExpressionPtr )\n"
"    return add_global_var_any(mod, vname, vat, TypeDeclFlags removeConstant, val"
"ue, true)\n"
"\n"
"def add_global_private_let ( mod:Module?; vname:string; vat:LineInfo; var value:"
"ExpressionPtr )\n"
"    return add_global_var_any(mod, vname, vat, TypeDeclFlags constant, value, tr"
"ue)\n"
"\n"
"def make_unique_private_name ( prefix:string; vat:LineInfo )\n"
"    return \"{prefix}_{vat.line}_{vat.column}\"\n"
"\n"
"def apply_template ( at:LineInfo; var expr:smart_ptr<Expression>; blk:block<(var"
" rules:Template):void>; forceAt:bool = true )\n"
"    var rules : Template\n"
"    invoke(blk, rules)\n"
"    apply_template(rules, at, expr, forceAt)\n"
"    delete rules\n"
