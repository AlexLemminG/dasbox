//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options indenting = 4\n"
"\n"
"module json shared public\n"
"\n"
"require strings\n"
"\n"
"variant JsValue\n"
"    _object : table<string; JsonValue?>\n"
"    _array  : array<JsonValue?>\n"
"    _string : string\n"
"    _number : double\n"
"    _bool   : bool\n"
"    _null   : void?\n"
"\n"
"struct JsonValue\n"
"    value : JsValue\n"
"\n"
"variant Token\n"
"    _string : string\n"
"    _number : double\n"
"    _bool   : bool\n"
"    _null   : void?\n"
"    _symbol : int\n"
"    _error  : string\n"
"\n"
"let\n"
"    Token_string = typeinfo(variant_index<_string> type<Token>)\n"
"    Token_symbol = typeinfo(variant_index<_symbol> type<Token>)\n"
"\n"
"def JV ( v : string )\n"
"    return new [[JsonValue value <- [[JsValue _string = v]]]]\n"
"\n"
"def JV ( v : double )\n"
"    return new [[JsonValue value <- [[JsValue _number = v]]]]\n"
"\n"
"def JV ( v : bool )\n"
"    return new [[JsonValue value <- [[JsValue _bool = v]]]]\n"
"\n"
"def JV ( v : void? )\n"
"    return new [[JsonValue value <- [[JsValue _null = null]]]]\n"
"\n"
"def JV ( var v : table<string;JsonValue?> )\n"
"    return new [[JsonValue value <- [[JsValue _object <- v]]]]\n"
"\n"
"def JV ( var v : array<JsonValue?> )\n"
"    return new [[JsonValue value <- [[JsValue _array <- v]]]]\n"
"\n"
"def private lexer ( text : string )\n"
"    var stext = clone_string(text)\n"
"    return <- _lexer(stext)\n"
"\n"
"def private lexer ( text : array<uint8> )\n"
"    var stext = string(text)\n"
"    return <- _lexer(stext)\n"
"\n"
"def private _lexer ( var stext : string implicit )\n"
"    return <- generator<Token>() <|\n"
"        var tin : iterator<int>\n"
"        unsafe\n"
"            tin <- each(stext)\n"
"        var ahead : int = ' '\n"
"        var str : array<uint8>\n"
"        while !empty(tin)\n"
"            while is_white_space(ahead) && next(tin,ahead)\n"
"                pass\n"
"            if empty(tin)\n"
"                return false\n"
"            if ahead=='[' || ahead==']' || ahead=='{' || ahead=='}' || ahead==':"
"' || ahead==','\n"
"                yield [[Token _symbol=ahead]]\n"
"                next(tin, ahead)\n"
"            elif ahead=='\"'\n"
"                while next(tin,ahead) && ahead!='\"'\n"
"                    if ahead == '\\\\'\n"
"                        if next(tin,ahead)\n"
"                            if ahead=='b'\n"
"                                ahead = '\\b'\n"
"                            elif ahead=='f'\n"
"                                ahead = '\\f'\n"
"                            elif ahead=='n'\n"
"                                ahead = '\\n'\n"
"                            elif ahead=='r'\n"
"                                ahead = '\\r'\n"
"                            elif ahead=='t'\n"
"                                ahead = '\\t'\n"
"                            push(str,uint8(ahead))\n"
"                        else\n"
"                            yield [[Token _error = \"string escape sequence excee"
"ds text\"]]\n"
"                            return false\n"
"                    else\n"
"                        push(str,uint8(ahead))\n"
"                if empty(tin)\n"
"                    yield [[Token _error = \"string exceeds text\"]]\n"
"                    return false\n"
"                yield [[Token _string = string(str)]]\n"
"                clear(str)\n"
"                next(tin, ahead)\n"
"            elif ahead=='+' || ahead=='-' || is_number(ahead)\n"
"                push(str,uint8(ahead))\n"
"                while next(tin,ahead) && is_number(ahead)\n"
"                    push(str,uint8(ahead))\n"
"                if !empty(tin) && ahead=='.'\n"
"                    push(str,uint8(ahead))\n"
"                    while next(tin,ahead) && is_number(ahead)\n"
"                        push(str,uint8(ahead))\n"
"                if !empty(tin) && (ahead=='e' || ahead=='E')\n"
"                    push(str,uint8(ahead))\n"
"                    next(tin,ahead)\n"
"                    if ahead=='+' || ahead=='-' || is_number(ahead)\n"
"                        push(str,uint8(ahead))\n"
"                    while next(tin,ahead) && is_number(ahead)\n"
"                        push(str,uint8(ahead))\n"
"                var num = string(str)\n"
"                yield [[Token _number = double(num)]]\n"
"                clear(str)\n"
"                unsafe\n"
"                    delete_string(num)\n"
"            elif is_alpha(ahead)\n"
"                push(str,uint8(ahead))\n"
"                while next(tin,ahead) && is_alpha(ahead)\n"
"                    push(str,uint8(ahead))\n"
"                var name = string(str)\n"
"                if name == \"true\"\n"
"                    yield [[Token _bool=true]]\n"
"                elif name == \"false\"\n"
"                    yield [[Token _bool=false]]\n"
"                elif name == \"null\"\n"
"                    yield [[Token _null = null]]\n"
"                else\n"
"                    yield [[Token _error = \"invalid name {name}\"]]\n"
"                    return false\n"
"                unsafe\n"
"                    delete_string(name)\n"
"                clear(str)\n"
"            else\n"
"                yield [[Token _error = \"invalid character `{to_char(ahead)}` aka"
" ASCII {ahead}\"]]\n"
"                return false\n"
"        return false\n"
"    finally\n"
"        unsafe\n"
"            delete_string(stext)\n"
"\n"
"def private expect_token ( var itv : iterator<Token>; var ahead : Token; vindex "
": int; var error : string & ) : bool\n"
"    if !next(itv, ahead)\n"
"        error = \"unexected eos\"\n"
"        return false\n"
"    elif variant_index(ahead) != vindex\n"
"        error = \"unexpected {ahead}, expecting variant {vindex}\"\n"
"        return false\n"
"    else\n"
"        return true\n"
"\n"
"def private expect_symbol ( var itv : iterator<Token>; var ahead : Token; sym : "
"int; var error : string & ) : bool\n"
"    if !next(itv, ahead)\n"
"        error = \"unexected eos\"\n"
"        return false\n"
"    elif ! ahead is _symbol\n"
"        error = \"unexpected {ahead}, expecting symbol\"\n"
"        return false\n"
"    elif !(ahead as _symbol == sym)\n"
"        error = \"unexpected {ahead}, expecting symbol `{to_char(sym)}` aka ASCII"
" {sym}\"\n"
"        return true\n"
"    else\n"
"        return true\n"
"\n"
"def private parse_value ( var itv : iterator<Token>; var error : string & ) : Js"
"onValue?\n"
"    var ahead : Token\n"
"    if !next(itv, ahead)\n"
"        return null\n"
"    if ahead is _symbol\n"
"        let sym = ahead as _symbol\n"
"        if sym == ']'\n"
"            error = \"unexpected ]\"\n"
"            return null\n"
"        if sym == '['\n"
"            var arr : array<JsonValue?>\n"
"            while !empty(itv)\n"
"                var value = parse_value(itv, error)\n"
"                if value == null\n"
"                    if error==\"unexpected ]\" && length(arr)==0\n"
"                        error = \"\"\n"
"                        return JV(arr)\n"
"                    return null\n"
"                push(arr, value)\n"
"                if !expect_token(itv, ahead, Token_symbol, error)\n"
"                    return null\n"
"                let sepsym = ahead as _symbol\n"
"                if sepsym == ']'\n"
"                    break\n"
"                elif sepsym != ','\n"
"                    error = \"unsepected array seaprator symbol `{to_char(sepsym)"
"}` aka ASCII {sepsym}\"\n"
"                    return null\n"
"            if empty(itv)\n"
"                error = \"unexpected eos\"\n"
"                return null\n"
"            return JV(arr)\n"
"        elif sym == '{'\n"
"            var tab : table<string; JsonValue?>\n"
"            while !empty(itv)\n"
"                if !expect_token(itv, ahead, Token_string, error)\n"
"                    if (ahead is _symbol) && (ahead as _symbol)=='}' && length(t"
"ab)==0\n"
"                        error = \"\"\n"
"                        return JV(tab)\n"
"                    return null\n"
"                var key = ahead as _string\n"
"                if !expect_symbol(itv, ahead, ':', error)\n"
"                    return null\n"
"                var value = parse_value(itv, error)\n"
"                if value == null\n"
"                    return null\n"
"                if key_exists(tab,key)\n"
"                    error = \"duplicate key {key}\"\n"
"                    return null\n"
"                tab[key] = value\n"
"                if !expect_token(itv, ahead, Token_symbol, error)\n"
"                    return null\n"
"                let sepsym = ahead as _symbol\n"
"                if sepsym == '}'\n"
"                    break\n"
"                elif sepsym != ','\n"
"                    error = \"unsepected object seaprator symbol `{to_char(sepsym"
")}` aka ASCII {sepsym}\"\n"
"                    return null\n"
"            if empty(itv)\n"
"                error = \"unexpected eos\"\n"
"                return null\n"
"            return JV(tab)\n"
"        else\n"
"            error = \"unexpected symbol `{to_char(sym)}` aka ASCII {sym}\"\n"
"            return null\n"
"    elif ahead is _string\n"
"        return JV(ahead as _string)\n"
"    elif ahead is _number\n"
"        return JV(ahead as _number)\n"
"    elif ahead is _bool\n"
"        return JV(ahead as _bool)\n"
"    elif ahead is _null\n"
"        return JV(null)\n"
"    else\n"
"        error = \"{ahead}\"\n"
"        return null\n"
"\n"
"def read_json ( text : string implicit; var error : string& ) : JsonValue?\n"
"    var lex <- lexer(text)\n"
"    let res = parse_value(lex,error)\n"
"    delete lex\n"
"    return res\n"
"\n"
"def read_json ( text : array<uint8>; var error : string& ) : JsonValue?\n"
"    var lex <- lexer(text)\n"
"    let res = parse_value(lex,error)\n"
"    delete lex\n"
"    return res\n"
"\n"
"// note - we use StringBuilderWriter for performance reasons here\n"
"def private write_value ( var writer : StringBuilderWriter; jsv : JsonValue?; de"
"pth : int )\n"
"    if jsv == null\n"
"        write(writer, \"null\")\n"
"    elif jsv.value is _string\n"
"        write(writer, \"\\\"\")\n"
"        write_escape_string(writer, jsv.value as _string)\n"
"        write(writer, \"\\\"\")\n"
"    elif jsv.value is _number\n"
"        write(writer, jsv.value as _number)\n"
"    elif jsv.value is _array\n"
"        if length(jsv.value as _array)==0\n"
"            write(writer, \"[]\")\n"
"        else\n"
"            write(writer, \"[\\n\")\n"
"            var first = true\n"
"            for elem in jsv.value as _array\n"
"                if first\n"
"                    first = false\n"
"                else\n"
"                    write(writer,\",\\n\")\n"
"                write_chars(writer,'\\t',depth+1)\n"
"                write_value(writer, elem, depth+1)\n"
"            write(writer, \"\\n\")\n"
"            write_chars(writer,'\\t',depth)\n"
"            write(writer, \"]\")\n"
"    elif jsv.value is _object\n"
"        if length(jsv.value as _object)==0\n"
"            write(writer, \"\\{\\}\")\n"
"        else\n"
"            write(writer, \"\\{\\n\")\n"
"            var first = true\n"
"            for elemK, elemV in keys(jsv.value as _object), values(jsv.value as "
"_object)\n"
"                if first\n"
"                    first = false\n"
"                else\n"
"                    write(writer,\",\\n\")\n"
"                write_chars(writer,'\\t',depth+1)\n"
"                write(writer, \"\\\"\")\n"
"                write_escape_string(writer, elemK)\n"
"                write(writer, \"\\\" : \")\n"
"                write_value(writer, elemV, depth+1)\n"
"            write(writer, \"\\n\")\n"
"            write_chars(writer,'\\t',depth)\n"
"            write(writer, \"\\}\")\n"
"    elif jsv.value is _bool\n"
"        if jsv.value as _bool\n"
"            write(writer, \"true\")\n"
"        else\n"
"            write(writer, \"false\")\n"
"    elif jsv.value is _null\n"
"        write(writer, \"null\")\n"
"    else\n"
"        panic(\"unexpected {jsv}\")\n"
"\n"
"def write_json ( val : JsonValue? ) : string\n"
"    let st = build_string() <| $ (var writer)\n"
"        write_value(writer, val, 0)\n"
"    return st\n"
