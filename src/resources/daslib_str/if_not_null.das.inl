//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options indenting = 4\n"
"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options no_aot = true\n"
"\n"
"module if_not_null shared private\n"
"\n"
"require ast\n"
"require rtti\n"
"require daslib/ast_boost\n"
"require daslib/templates_boost\n"
"\n"
"/*\n"
"    transforms\n"
"        ptr |> if_not_null() <| call(...)\n"
"    to\n"
"        var _ptr_var = ptr\n"
"        if _ptr_var\n"
"            call(*_ptr_var,...)\n"
"*/\n"
"[call_macro(name=\"if_not_null\")]\n"
"class ApplyMacro : AstCallMacro\n"
"    if_not_null_index : int = 0\n"
"    def override visit ( prog:ProgramPtr; mod:Module?; var expr:smart_ptr<ExprCa"
"llMacro> ) : ExpressionPtr\n"
"        if expr.arguments.length !=2\n"
"            macro_error(prog,expr.at,\"expecting 2 arguments, expecting ptr |> if"
"_not_null() <| call()\")\n"
"            return [[ExpressionPtr]]\n"
"        if !(expr.arguments[1] is ExprCall)\n"
"            macro_error(prog,expr.at,\"2nd argument must be call(), expecting ptr"
" |> if_not_null() <| call()\")\n"
"            return [[ExpressionPtr]]\n"
"        if expr.arguments[0]._type!=null    // need value inferred\n"
"            if !expr.arguments[0]._type.isPointer\n"
"                macro_error(prog,expr.at,\"first argument must be pointer , expec"
"ting ptr |> if_not_null() <| call()\")\n"
"                return [[ExpressionPtr]]\n"
"            var ifnn_name = \"__ifnn_ptr_{if_not_null_index++}\"\n"
"            // var vptr = ptr\n"
"            var vlet <- new [[ExprLet() at=expr.at,atInit=expr.at]]\n"
"            vlet.variables |> emplace_new() <| new [[Variable() at=expr.at,\n"
"                    name := ifnn_name,\n"
"                    _type <- new [[TypeDecl() baseType=Type autoinfer, at=expr.a"
"t]],\n"
"                    init <- clone_expression(expr.arguments[0])\n"
"                ]]\n"
"            if !expr.arguments[0]._type.flags.constant\n"
"                vlet.variables[0]._type.flags |= TypeDeclFlags removeConstant\n"
"            // { somecall(ptr,...) }\n"
"            var eblk <- new [[ExprBlock() at=expr.at]]\n"
"            var fcall = expr.arguments[1] as ExprCall\n"
"            // note: this can be clone+push(ecall.arguments,arg,1) but we are no"
"t bining 'push at' yet\n"
"            var ecall <- new [[ExprCall() at=fcall.at, name:=fcall.name]]\n"
"            ecall.arguments |> emplace_new() <| new [[ExprPtr2Ref() at=expr.at,\n"
"                    subexpr <- new [[ExprVar() at=expr.at,name:=ifnn_name]]\n"
"                ]]\n"
"            for arg in fcall.arguments\n"
"                ecall.arguments |> emplace_new() <| clone_expression(arg)\n"
"            eblk.list |> emplace(ecall)\n"
"            // if ptr != null\n"
"            var eifnn <- new [[ExprIfThenElse() at=expr.at,\n"
"                cond <- new [[ExprOp2() at=expr.at,\n"
"                    op := \"!=\",\n"
"                    left <- new [[ExprVar() at=expr.at,name:=ifnn_name]],\n"
"                    right <- new [[ExprConstPtr() at=expr.at]]\n"
"                ]],\n"
"                if_true <- eblk\n"
"            ]]\n"
"            // tblk\n"
"            var tblk <- new [[ExprBlock() at=expr.at]]\n"
"            tblk.list |> emplace(vlet)\n"
"            tblk.list |> emplace(eifnn)\n"
"            return tblk\n"
"        return [[ExpressionPtr]]\n"
"\n"
