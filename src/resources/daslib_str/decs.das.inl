//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options indenting = 4\n"
"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"\n"
"module decs shared public\n"
"\n"
"require daslib/templates\n"
"\n"
"require daslib/rtti public\n"
"require daslib/algorithm\n"
"require daslib/sort_boost\n"
"require daslib/functional\n"
"\n"
"typedef ComponentHash = uint\n"
"\n"
"struct public Component\n"
"    name : string\n"
"    hash : ComponentHash\n"
"    stride : int\n"
"    data : array<uint8>\n"
"    info : TypeInfo const?\n"
"\n"
"struct public EntityId\n"
"    id : uint\n"
"    generation : int\n"
"\n"
"struct public Archetype\n"
"    hash : ComponentHash\n"
"    components : array<Component>\n"
"    size : int\n"
"    eidIndex : int\n"
"\n"
"struct public ComponentValue\n"
"    name : string\n"
"    info : TypeInfo const?\n"
"    data : float4\n"
"\n"
"typedef DeferEval = lambda<():void>\n"
"\n"
"struct private DeferAction\n"
"    eid : EntityId\n"
"    action : DeferEval\n"
"\n"
"typedef ComponentMap = array<ComponentValue>\n"
"\n"
"struct public EcsRequest\n"
"    hash : ComponentHash\n"
"    req : array<string>\n"
"    reqn : array<string>\n"
"\n"
"enum private ReqLookup\n"
"    dontKnow\n"
"    yes\n"
"    no\n"
"\n"
"var private requestLookup : table<uint64; ReqLookup>\n"
"var private archetypeLookup : table<ComponentHash; int>\n"
"var private allArchetypes : array<Archetype>\n"
"var private deferActions : array<DeferAction>\n"
"var private entityFreeList : array<EntityId>\n"
"var private entityLookup : array<tuple<generation:int;archetype:ComponentHash;in"
"dex:int>>\n"
"var private componentTypeCheck : table<string; TypeInfo const?>\n"
"\n"
"def restart\n"
"    delete deferActions\n"
"    delete archetypeLookup\n"
"    delete allArchetypes\n"
"    delete entityFreeList\n"
"    delete entityLookup\n"
"    delete componentTypeCheck\n"
"    delete requestLookup\n"
"\n"
"def private new_entity_id()\n"
"    var eid : EntityId\n"
"    if !empty(entityFreeList)\n"
"        eid = entityFreeList[length(entityFreeList)-1]\n"
"        entityFreeList |> pop\n"
"    else\n"
"        eid.id = uint(length(entityLookup))\n"
"        entityLookup |> push([[auto 0,0u,0]])\n"
"    eid.generation ++\n"
"    return eid\n"
"\n"
"def public debug_dump\n"
"    for arch in allArchetypes\n"
"        print(\"archtype {arch.hash} : {arch.size}\\n\")\n"
"        // debug(arch)\n"
"        for index in range(arch.size)\n"
"            print(\"\\tentity[{index}]\\n\")\n"
"            for c in arch.components\n"
"                unsafe\n"
"                    print(\"\\t\\t{c.name} : {describe(c.info)} = {sprint_data(addr"
"(c.data[index*c.stride]),c.info,print_flags humanReadable)}\\n\")\n"
"\n"
"def private with_archetype ( hash:ComponentHash; blk : block<(var arch:Archetype"
"; isNew:bool ):void> )\n"
"    var afound & = archetypeLookup[hash]\n"
"    if afound==0\n"
"        allArchetypes |> emplace([[Archetype hash=hash]])\n"
"        afound = length(allArchetypes)\n"
"        invoke(blk, allArchetypes[afound-1], true)\n"
"    else\n"
"        invoke(blk, allArchetypes[afound-1], false)\n"
"\n"
"def private create_archetype ( var arch:Archetype; cmp:ComponentMap )\n"
"    assert(length(arch.components)==0)\n"
"    arch.eidIndex = -1\n"
"    for kv,kvi in cmp,range(100500)\n"
"        var ct & = componentTypeCheck[kv.name]\n"
"        if ct != null\n"
"            if kv.info.hash != (*ct).hash\n"
"                panic(\"component {kv.name} type mismatch {describe(ct)} vs {desc"
"ribe(kv.info)}\")\n"
"        else\n"
"            ct = kv.info\n"
"        let chash = hash(kv.name)\n"
"        arch.components |> emplace <| [[Component\n"
"            name=kv.name,\n"
"            hash=chash,\n"
"            stride=int(kv.info.size),\n"
"            info=kv.info\n"
"        ]]\n"
"        if kv.name==\"eid\"\n"
"            assert(arch.eidIndex==-1)\n"
"            arch.eidIndex = kvi\n"
"    assert(arch.eidIndex!=-1)\n"
"\n"
"def private get_eid ( var arch:Archetype; index:int ) : EntityId &\n"
"    unsafe\n"
"        var ceid & = arch.components[arch.eidIndex]\n"
"        return *(reinterpret<EntityId?> addr(ceid.data[index*ceid.stride]))\n"
"\n"
"def private create_entity ( var arch:Archetype; eid:EntityId; cmp:ComponentMap )"
"\n"
"    let eidx = arch.size++\n"
"    for c,comp in arch.components,cmp\n"
"        c.data |> resize(length(c.data) + c.stride)\n"
"        unsafe\n"
"            memcpy ( addr(c.data[eidx*c.stride]), addr(comp.data), c.stride )\n"
"    return eidx\n"
"\n"
"def private remove_entity ( var arch:Archetype; di:int )\n"
"    arch.size --\n"
"    if di!=arch.size    // copy last one in the hole\n"
"        var eid_last & = arch |> get_eid(arch.size)\n"
"        entityLookup[eid_last.id].index = di\n"
"        for c in arch.components\n"
"            unsafe\n"
"                memcpy ( addr(c.data[di*c.stride]), addr(c.data[arch.size*c.stri"
"de]), c.stride )\n"
"    for c in arch.components\n"
"        c.data |> resize ( arch.size * c.stride )\n"
"\n"
"def private cmp_archetype_hash ( cmp:ComponentMap )\n"
"    var ahash : ComponentHash\n"
"    for kv in cmp\n"
"        ahash = (ahash<<<2u) ^ hash(kv.name)\n"
"    return ahash\n"
"\n"
"def private req_hash ( erq : EcsRequest )\n"
"    var ahash : ComponentHash\n"
"    for kv in erq.req\n"
"        ahash = (ahash<<<2u) ^ hash(kv)\n"
"    for kv in erq.reqn\n"
"        ahash = (ahash<<<2u) ^ ~hash(kv)\n"
"    return ahash\n"
"\n"
"def public has ( arch:Archetype; name:string )\n"
"    return arch.components |> binary_search ( [[Component name=name]] ) <| $ ( x"
", y ) => x.name < y.name\n"
"\n"
"def private can_process_request ( var erq : EcsRequest; var arch : Archetype )\n"
"    if erq.hash==arch.hash\n"
"        return true\n"
"    let key = (uint64(erq.hash)<<<32ul) ^ (uint64(arch.hash))\n"
"    var rlook & = requestLookup[key]\n"
"    if rlook==ReqLookup dontKnow\n"
"        rlook = ReqLookup yes\n"
"        for r in erq.req\n"
"            if ! arch |> has(r)\n"
"                rlook = ReqLookup no\n"
"                break\n"
"        if rlook == ReqLookup yes\n"
"            for r in erq.reqn\n"
"                if arch |> has(r)\n"
"                    rlook = ReqLookup no\n"
"                    break\n"
"    return rlook==ReqLookup yes\n"
"\n"
"def public verify_request ( var erq : EcsRequest ) : tuple<ok:bool;error:string>"
"\n"
"    if erq.hash==0u || (empty(erq.req) && empty(erq.reqn))\n"
"        return [[auto false, \"missing components\"]]\n"
"    for N in erq.reqn   // assuming require_not is typically shorter\n"
"        if erq.req |> binary_search(N)\n"
"            return [[auto false, \"duplicate req and neq {N}\"]]\n"
"    return [[auto true,\"\"]]\n"
"\n"
"def public compile_request ( var erq : EcsRequest )\n"
"    if erq.hash==0u\n"
"        sort_unique(erq.req)\n"
"        sort_unique(erq.reqn)\n"
"        erq.hash = req_hash(erq)\n"
"\n"
"def public for_each_archetype ( var erq : EcsRequest; blk:block<(arch:Archetype)"
":void> )\n"
"    compile_request(erq)\n"
"    for arch in allArchetypes\n"
"        if arch.size > 0\n"
"            if erq |> can_process_request(arch)\n"
"                invoke ( blk, arch )\n"
"\n"
"[template(atype)]\n"
"def decs_array ( atype:auto(TT); src:array<uint8>; capacity:int ) : array<TT-con"
"st-&>#\n"
"    assert(length(src)>0)\n"
"    var dest : array<TT -const -&>#\n"
"    unsafe\n"
"        _builtin_make_temp_array(dest, addr(src[0]), capacity)\n"
"    __builtin_array_lock(dest)\n"
"    unsafe\n"
"        return <- dest\n"
"\n"
"def public get ( arch:Archetype; name:string; value:auto(TT) ) : array<TT-const-"
"&>#\n"
"    let idx = arch.components |> lower_bound([[Component name=name]]) <| $ ( x,y"
" ) => x.name < y.name\n"
"    if idx<length(arch.components)\n"
"        let comp & = arch.components[idx]\n"
"        if comp.name==name\n"
"            unsafe\n"
"                let cvinfo = addr(typeinfo(rtti_typeinfo type<TT-const-&>))\n"
"                if comp.info.hash != cvinfo.hash\n"
"                    panic(\"component array {name} type mismatch, expecting {comp"
".info} vs {describe(cvinfo)}\")\n"
"            unsafe\n"
"                return <- decs_array(type<TT>, comp.data, arch.size)\n"
"    panic(\"component array {name} not found\")\n"
"    unsafe\n"
"        return <- [[array<TT-const-&># ]]\n"
"\n"
"def public get_ro ( arch:Archetype; name:string; value:auto(TT) ) : array<TT-con"
"st-&> const#\n"
"    unsafe\n"
"        return <- get(arch, name, value)\n"
"\n"
"def public get_default_ro ( arch:Archetype; name:string; value:auto(TT) ) : iter"
"ator<TT const &>\n"
"    let idx = arch.components |> lower_bound([[Component name=name]]) <| $ ( x,y"
" ) => x.name < y.name\n"
"    if idx<length(arch.components)\n"
"        let comp & = arch.components[idx]\n"
"        if comp.name==name\n"
"            unsafe\n"
"                let cvinfo = addr(typeinfo(rtti_typeinfo type<TT-const-&>))\n"
"                if comp.info.hash != cvinfo.hash\n"
"                    panic(\"component array {name} type mismatch, expecting {comp"
".info} vs {describe(cvinfo)}\")\n"
"            var it : iterator<TT const &>\n"
"            unsafe\n"
"                _builtin_make_fixed_array_iterator(it,addr(comp.data[0]),arch.si"
"ze,comp.stride)\n"
"            return <- it\n"
"    return <- repeat_ref(value,arch.size)\n"
"\n"
"def private update_entity_imm ( eid:EntityId; blk : lambda<(eid:EntityId; var cm"
"p:ComponentMap):void> )\n"
"    var lookup & = entityLookup[eid.id]\n"
"    if lookup.generation != eid.generation\n"
"        return\n"
"    var cmp : ComponentMap\n"
"    var arch & = allArchetypes[archetypeLookup[lookup.archetype]-1]\n"
"    let eidx = entityLookup[eid.id].index\n"
"    cmp |> reserve ( length(arch.components) )\n"
"    for c in arch.components\n"
"        var value = [[ComponentValue name=c.name, info=c.info]]\n"
"        unsafe\n"
"            memcpy ( addr(value.data), addr(c.data[eidx*c.stride]), c.stride)\n"
"        cmp |> push(value)\n"
"    var old_ahash = arch.hash\n"
"    invoke(blk, eid, cmp)\n"
"    cmp |> set(\"eid\", eid)  // necessary?\n"
"    var new_ahash = cmp_archetype_hash(cmp)\n"
"    if old_ahash == new_ahash\n"
"        for c,comp in arch.components,cmp\n"
"            unsafe\n"
"                memcpy ( addr(c.data[eidx*c.stride]), addr(comp.data), c.stride "
")\n"
"    else\n"
"        arch |> remove_entity ( eidx )\n"
"        with_archetype(new_ahash) <| $ ( var narch; isNew )\n"
"            if isNew\n"
"                narch |> create_archetype(cmp)\n"
"            let neidx = narch |> create_entity(eid, cmp)\n"
"            entityLookup[eid.id] = [[auto eid.generation,new_ahash,neidx]]\n"
"    delete cmp\n"
"\n"
"def private create_entity_imm ( eid:EntityId; blk : lambda<(eid:EntityId; var cm"
"p:ComponentMap):void> )\n"
"    var cmp : ComponentMap\n"
"    cmp |> push <| make_component(\"eid\", eid)\n"
"    invoke(blk, eid, cmp)\n"
"    cmp |> set(\"eid\", eid)       // necessary?\n"
"    var ahash = cmp_archetype_hash(cmp)\n"
"    with_archetype(ahash) <| $ ( var arch; isNew )\n"
"        if isNew\n"
"            arch |> create_archetype(cmp)\n"
"        let eidx = arch |> create_entity(eid,cmp)\n"
"        entityLookup[eid.id] = [[auto eid.generation,ahash,eidx]]\n"
"    delete cmp\n"
"\n"
"def private delete_entity_imm ( eid:EntityId )\n"
"    var lookup & = entityLookup[eid.id]\n"
"    if lookup.generation == eid.generation\n"
"        var arch & = allArchetypes[archetypeLookup[lookup.archetype]-1]\n"
"        let di = entityLookup[eid.id].index\n"
"        entityLookup[eid.id].generation = 0\n"
"        entityFreeList |> push(eid)\n"
"        arch |> remove_entity(di)\n"
"\n"
"def public update_entity ( entityid:EntityId; var blk : lambda<(eid:EntityId; va"
"r cmp:ComponentMap):void> )\n"
"    var eid = entityid\n"
"    var deval <- @ <| [[<-blk]]\n"
"        update_entity_imm(eid,blk)\n"
"    deferActions |> emplace([[DeferAction action<-deval]])\n"
"\n"
"def public create_entity ( var blk : lambda<(eid:EntityId; var cmp:ComponentMap)"
":void> )\n"
"    var eid = new_entity_id()\n"
"    var deval <- @ <| [[<-blk]]\n"
"        create_entity_imm(eid, blk)\n"
"    deferActions |> emplace([[DeferAction action<-deval]])\n"
"    return eid\n"
"\n"
"def public delete_entity ( entityid:EntityId )\n"
"    var eid = entityid\n"
"    var deval <- @ <|\n"
"        delete_entity_imm(eid)\n"
"    deferActions |> emplace([[DeferAction action<-deval]])\n"
"\n"
"def public commit\n"
"    for da in deferActions\n"
"        da.action |> invoke\n"
"    delete deferActions\n"
"\n"
"def public get ( var cmp:ComponentMap; name:string; var value:auto(TT) )\n"
"    let idx = lower_bound(cmp,[[ComponentValue name=name]]) <| $ ( x,y ) => x.na"
"me < y.name\n"
"    if idx<length(cmp) && cmp[idx].name==name\n"
"        unsafe\n"
"            let cvinfo = addr(typeinfo(rtti_typeinfo type<TT-const-&-#>))\n"
"            if cmp[idx].info.hash != cvinfo.hash\n"
"                panic(\"get component {name} type mismatch, expecting {describe(c"
"mp[idx].info)} vs {describe(cvinfo)}\")\n"
"            memcpy ( addr(value), addr(cmp[idx].data), typeinfo(sizeof type<TT c"
"onst-&>))\n"
"    return value\n"
"\n"
"def private make_component ( name:string; value:auto(TT) )\n"
"    var cv = [[ComponentValue name=name]]\n"
"    unsafe\n"
"        cv.info = addr(typeinfo(rtti_typeinfo type<TT-const-&-#>))\n"
"        memcpy ( addr(cv.data), addr(value), typeinfo(sizeof value))\n"
"    return cv\n"
"\n"
"def public set ( var cmp:ComponentMap; name:string; value:auto(TT) )\n"
"    concept_assert((typeinfo(is_pod value) || typeinfo(is_string value))\n"
"        && typeinfo(sizeof value)<=16, \"unsupported component type {typeinfo(typ"
"ename value)}\")\n"
"    let cv = make_component(name, value)\n"
"    let idx = lower_bound(cmp,[[ComponentValue name=name]]) <| $ ( x,y ) => x.na"
"me < y.name\n"
"    if idx<length(cmp) && cmp[idx].name==name\n"
"        if cmp[idx].info.hash != cv.info.hash\n"
"            panic(\"set component {name} type mismatch, expecting {describe(cmp[i"
"dx].info)} vs {describe(cv.info)}\")\n"
"        cmp[idx] = cv           // overwrite\n"
"    else\n"
"        cmp |> push(cv, idx)    // insert new one\n"
"\n"
"def public has ( var cmp:ComponentMap; name:string )\n"
"    return binary_search(cmp,[[ComponentValue name=name]]) <| $ ( x,y ) => x.nam"
"e < y.name\n"
"\n"
"def public remove ( var cmp:ComponentMap; name:string )\n"
"    let idx = lower_bound(cmp,[[ComponentValue name=name]]) <| $ ( x,y ) => x.na"
"me < y.name\n"
"    if idx<length(cmp) && cmp[idx].name==name\n"
"        cmp |> erase(idx)\n"
