//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options indenting = 4\n"
"\n"
"module functional shared public\n"
"\n"
"def private filter_any(var src:iterator<auto(TT)>; var blk )\n"
"    static_if !typeinfo(is_ref_type type<TT>)\n"
"        return <- generator<TT -&> [[<-src,<-blk]] () <| $ ()\n"
"            for w in src\n"
"                if invoke(blk,w)\n"
"                    yield w\n"
"            return false\n"
"    else\n"
"        return <- generator<TT&> [[<-src,<-blk]] () <| $ ()\n"
"            for w in src\n"
"                if invoke(blk,w)\n"
"                    yield w\n"
"            return false\n"
"\n"
"def filter(var src:iterator<auto(TT)>; blk:lambda<(what:TT -&):bool> )\n"
"    return <- filter_any(src,blk)\n"
"\n"
"// filter with function\n"
"def filter(var src:iterator<auto(TT)>; blk:function<(what:TT -&):bool> )\n"
"    return <- filter_any(src,blk)\n"
"\n"
"def private map_any(var src:iterator<auto(TT)>; var blk)\n"
"    static_if typeinfo(can_copy type<QQ>)\n"
"        return <- generator<QQ -&> [[<-src,<-blk]] () <| $ ()\n"
"            for w in src\n"
"                yield invoke(blk,w)\n"
"            return false\n"
"    static_elif typeinfo(can_move type<QQ>)\n"
"        return <- generator<QQ -&> [[<-src,<-blk]] () <| $ ()\n"
"            for w in src\n"
"                yield <- invoke(blk,w)\n"
"            return false\n"
"    else\n"
"        concept_assert(false,\"can't copy or move return type\")\n"
"        var dummy : iterator<QQ>\n"
"        return <- dummy\n"
"\n"
"\n"
"// map with lambda\n"
"def map(var src:iterator<auto(TT)>; blk:lambda<(what:TT -&):auto(QQ)>)\n"
"    return <- map_any(src,blk)\n"
"\n"
"// map with function\n"
"def map(var src:iterator<auto(TT)>; blk:function<(what:TT -&):auto(QQ)>)\n"
"    return <- map_any(src,blk)\n"
"\n"
"// reduce value, any invokable\n"
"def private reduce_any(it:iterator<auto(TT)>;functor)\n"
"    var left : TT -&\n"
"    var first = true\n"
"    for right in it\n"
"        if first\n"
"            first = false\n"
"            left = right\n"
"        else\n"
"            left = invoke(functor,left,right)\n"
"    if first\n"
"        panic(\"can't reduce empty sequence\")\n"
"    return left\n"
"\n"
"// reduce with lambda\n"
"def reduce(it:iterator<auto(TT)>;blk:lambda<(left,right:TT -&):TT const -&>)\n"
"    return reduce_any(it,blk)\n"
"\n"
"// reduce with function\n"
"def reduce(it:iterator<auto(TT)>;blk:function<(left,right:TT -&):TT const -&>)\n"
"    return reduce_any(it,blk)\n"
"\n"
"// reduce with block\n"
"def reduce(it:iterator<auto(TT)>;blk:block<(left,right:TT -&):TT const -&>)\n"
"    return reduce_any(it,blk)\n"
"\n"
"// summ of all elements\n"
"//  same as reduce(it, @(a,b) => a + b)\n"
"def sum(it:iterator<auto(TT)>)\n"
"    var temp : TT -&\n"
"    for x in it\n"
"        temp += x\n"
"    return temp\n"
"\n"
"// any\n"
"def any ( it )\n"
"    static_if !typeinfo(is_iterable it)\n"
"        concept_assert(false,\"can't ANY non-iterable type\")\n"
"        return false\n"
"    else\n"
"        for x in it\n"
"            if x\n"
"                return true\n"
"        return false\n"
"\n"
"// all\n"
"def all ( it )\n"
"    static_if !typeinfo(is_iterable it)\n"
"        concept_assert(false,\"can't ALL non-iterable type\")\n"
"        return false\n"
"    else\n"
"        for x in it\n"
"            if !x\n"
"                return false\n"
"        return true\n"
"\n"
"def cycle(var src:iterator<auto(TT)>)\n"
"    static_if !typeinfo(is_ref_type type<TT>)\n"
"        return <- generator<TT -&> [[<-src]] () <| $ ()\n"
"            var arr : array<TT -&>\n"
"            for x in src\n"
"                yield x\n"
"                push(arr,x)\n"
"            while true\n"
"                for x in arr\n"
"                    yield x\n"
"            return false\n"
"        finally\n"
"            __builtin_array_clear_lock(arr)\n"
"    else\n"
"        return <- generator<TT &> [[<-src]] () <| $ ()\n"
"            var arr : array<TT -&>\n"
"            for x in src\n"
"                yield x\n"
"                push_clone(arr,x)\n"
"            while true\n"
"                for x in arr\n"
"                    yield x\n"
"            return false\n"
"        finally\n"
"            __builtin_array_clear_lock(arr)\n"
"\n"
"def islice( var src : iterator<auto(TT)>; start,stop : int )\n"
"    static_if !typeinfo(is_ref_type type<TT>)\n"
"        return <- generator<TT -&> [[<-src]] () <| $ ()\n"
"            for x,i in src,range(stop)\n"
"                if i>=start\n"
"                    yield x\n"
"            return false\n"
"    else\n"
"        return <- generator<TT &> [[<-src]] () <| $ ()\n"
"            for x,i in src,range(stop)\n"
"                if i>=start\n"
"                    yield x\n"
"            return false\n"
"\n"
"// [[ start; start+step; start+2*step ]]\n"
"[generic]\n"
"def count(var start,step:int) : iterator<int>\n"
"    return <- each() <| @(var result:int&) : bool\n"
"        result = start\n"
"        start += step\n"
"        return true\n"
"\n"
"// [[ value; value; value; .... count times ]]\n"
"def repeat(value : auto(TT); var count : int = 0)\n"
"    return <- generator<TT> () <| $ ()\n"
"        if count == 0\n"
"            while true\n"
"                yield value\n"
"        for x in range(count)\n"
"            yield value\n"
"        return false\n"
"\n"
"def is_equal(a,b)\n"
"    return a == b\n"
"\n"
"def is_not_equal(a,b)\n"
"    return a != b\n"
"\n"
"def not(x)\n"
"    return !x\n"
"\n"
"def echo(var x;extra : string = \"\\n\")\n"
"    print(\"{x}{extra}\")\n"
"    return <- x\n"
