//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options indenting = 4\n"
"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"\n"
"module sort_boost shared private\n"
"\n"
"require ast\n"
"\n"
"require daslib/templates public\n"
"require daslib/contracts public\n"
"require daslib/ast_boost\n"
"\n"
"[unsafe_operation, template (a), unused_argument(a)]\n"
"def private sort_array_helper ( var arr : auto implicit; a : auto(TT) ) : array<"
"TT -#>\n"
"    var res : array<TT -#>\n"
"    let lenA = length(arr)\n"
"    if lenA>=1\n"
"        unsafe\n"
"            _builtin_make_temp_array(res, addr(arr[0]), lenA)\n"
"    return <- res\n"
"\n"
"[unsafe_operation]\n"
"def public temp_sort_array ( var arr : auto implicit )\n"
"    unsafe\n"
"        return <- sort_array_helper ( arr, decltype(arr[0]) )\n"
"\n"
"[call_macro(name=\"qsort\")]\n"
"class QsortMacro : AstCallMacro\n"
"    def override visit ( prog:ProgramPtr; mod:Module?; var expr:smart_ptr<ExprCa"
"llMacro> ) : ExpressionPtr\n"
"        if expr.arguments.length != 2\n"
"            macro_error(prog,expr.at,\"expecting qsort(value, block)\")\n"
"            return [[ExpressionPtr]]\n"
"        if expr.arguments[0]._type==null || expr.arguments[1]._type==null\n"
"            return [[ExpressionPtr]]\n"
"        // todo: verify correct block type?\n"
"        if expr.arguments[1]._type.baseType != Type tBlock\n"
"            macro_error(prog,expr.at,\"expecting 2nd argument to be block(<a,b:au"
"to(TT)>:bool))\")\n"
"            return [[ExpressionPtr]]\n"
"        if expr.arguments[0]._type.dim.length != 0 || expr.arguments[0]._type.ba"
"seType==Type tArray\n"
"            var call <- new [[ExprCall() name:=\"sort\", at=expr.at]]\n"
"            emplace_new(call.arguments) <| clone_expression(expr.arguments[0])\n"
"            emplace_new(call.arguments) <| clone_expression(expr.arguments[1])\n"
"            return <- call\n"
"        elif expr.arguments[0]._type.baseType==Type tHandle\n"
"            var call <- new [[ExprCall() name:=\"sort\", at=expr.at]]\n"
"            var tsa <- new [[ExprCall() name:=\"temp_sort_array\", at=expr.at]]\n"
"            emplace_new(tsa.arguments) <| clone_expression(expr.arguments[0])\n"
"            tsa.genFlags |= ExprGenFlags alwaysSafe\n"
"            emplace(call.arguments,tsa)\n"
"            emplace_new(call.arguments) <| clone_expression(expr.arguments[1])\n"
"            return <- call\n"
"        else\n"
"            macro_error(prog,expr.at,\"can only qsort [], array, or handled vecto"
"r\")\n"
"            return [[ExpressionPtr]]\n"
"\n"
