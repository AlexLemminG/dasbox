//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options indenting = 4\n"
"\n"
"module regex shared public\n"
"\n"
"require strings\n"
"\n"
"enum ReOp\n"
"    Char\n"
"    Set\n"
"    Any\n"
"    Eos\n"
"    Group\n"
"    Plus\n"
"    Star\n"
"    Question\n"
"    Concat\n"
"    Union\n"
"\n"
"typedef\n"
"    CharSet = uint[8]\n"
"\n"
"struct ReNode\n"
"    op      : ReOp\n"
"    id      : int\n"
"    [[do_not_convert]] fun2 : function< (var regex:Regex; var node:ReNode?; str:"
"uint8?) : uint8? >\n"
"    at      : range\n"
"    text    : string\n"
"    textLen : int\n"
"    all     : array<ReNode?>\n"
"    left    : ReNode?\n"
"    right   : ReNode?\n"
"    subexpr : ReNode?\n"
"    [[do_not_delete,do_not_convert]] next : ReNode?\n"
"    cset    : CharSet\n"
"    index   : int\n"
"    [[do_not_convert]] tail : uint8?\n"
"\n"
"struct Regex\n"
"    root        : ReNode?\n"
"    [[do_not_convert]] match : uint8?\n"
"    groups      : array<tuple<range;string>>\n"
"    earlyOut    : CharSet\n"
"    canEarlyOut : bool\n"
"\n"
"variant MaybeReNode\n"
"    value   : ReNode?\n"
"    nothing : void?\n"
"\n"
"/*\n"
"    Parser\n"
"*/\n"
"\n"
"let\n"
"    log_parse_enabled = false\n"
"    log_match_enabled = false\n"
"    range_check_enabled = false\n"
"\n"
"var\n"
"    trace_tab = 0\n"
"\n"
"def private trace(msg:string; offset:int)\n"
"    static_if log_parse_enabled\n"
"        print(\"{repeat(\" \",trace_tab)}{offset}: {msg}\\n\")\n"
"        trace_tab ++\n"
"\n"
"def private note(msg:string; offset:int)\n"
"    static_if log_parse_enabled\n"
"        print(\"{repeat(\" \",trace_tab)}{offset}: {msg}\\n\")\n"
"\n"
"def private trace_backtrack()\n"
"    static_if log_parse_enabled\n"
"        trace_tab --\n"
"        print(\"{repeat(\" \",trace_tab)}backtrack\\n\")\n"
"\n"
"def private trace_value(value : ReNode?)\n"
"    static_if log_parse_enabled\n"
"        if value==null\n"
"            panic(\"trace_value null?\")\n"
"        trace_tab --\n"
"        print(\"{repeat(\" \",trace_tab)}matched {value.op}, next {value.at.y}\\n\")\n"
"\n"
"def private nada()\n"
"    trace_backtrack()\n"
"    return [[MaybeReNode nothing=null]]\n"
"\n"
"def private maybe( value : ReNode? )\n"
"    trace_value(value)\n"
"    return [[MaybeReNode value=value]]\n"
"\n"
"def private eos(expr:string; offset:int)\n"
"    return offset >= length(expr)\n"
"\n"
"def private at(expr:string; offset:int) : int\n"
"    static_if range_check_enabled\n"
"        let len = length(expr)\n"
"        if offset<len\n"
"            return character_at(expr, offset)\n"
"        elif offset==len\n"
"            return 0\n"
"        else\n"
"            stackwalk()\n"
"            panic(\"out of range {offset} of {len}\")\n"
"            return 0\n"
"    else\n"
"        unsafe\n"
"            return character_uat(expr, offset)\n"
"\n"
"def private next(re:MaybeReNode)\n"
"    if !(re is value)\n"
"        stackwalk()\n"
"        panic(\"expecting value\")\n"
"    return (re as value).at.y\n"
"\n"
"def private is_set_empty(cset:CharSet)\n"
"    for x in cset\n"
"        if x != 0u\n"
"            return false\n"
"    return true\n"
"\n"
"def private set_or_char(var cset:CharSet; ch:int)\n"
"    cset[ch>>5] |= uint(1 << (ch & 31))\n"
"\n"
"def private set_or_range(var cset:CharSet; bits:range)\n"
"    for ch in range(bits.x,bits.y+1)\n"
"        cset[ch>>5] |= uint(1 << (ch & 31))\n"
"\n"
"def private set_invert(var cset:CharSet)\n"
"    for x in cset\n"
"        x ^= 0xffffffff\n"
"\n"
"def private set_or_set(var cset:CharSet; eset:CharSet)\n"
"    for x,y in cset,eset\n"
"        x |= y\n"
"\n"
"def private set_negative(var cset:CharSet)\n"
"    for x in cset\n"
"        x = ~x\n"
"\n"
"def private set_meta(var cset:CharSet; che:int)\n"
"    if che=='w'\n"
"        set_or_range(cset,range('a','z'))\n"
"        set_or_range(cset,range('A','Z'))\n"
"        set_or_range(cset,range('0','9'))\n"
"        set_or_char(cset,'_')\n"
"    elif che=='W'\n"
"        var eset:CharSet\n"
"        set_meta(eset,'w')\n"
"        set_or_set(cset,eset)\n"
"    elif che=='s'\n"
"        set_or_char(cset,' ')\n"
"        set_or_char(cset,'\\t')\n"
"    elif che=='S'\n"
"        var eset:CharSet\n"
"        set_meta(eset,'s')\n"
"        set_or_set(cset,eset)\n"
"    elif che=='d'\n"
"        set_or_range(cset,range('0','9'))\n"
"    elif che=='D'\n"
"        var eset:CharSet\n"
"        set_meta(eset,'d')\n"
"        set_or_set(cset,eset)\n"
"    else\n"
"        set_or_char(cset,che)\n"
"\n"
"let\n"
"    meta = \"\\\\+-*.()[]|^\"\n"
"    meta_set = \"wWsSdD\"\n"
"\n"
"def private is_meta_character(ch:int) : bool\n"
"    return find(meta,ch) != -1\n"
"\n"
"def private is_set_character(ch:int) : bool\n"
"    return find(meta_set,ch) != -1\n"
"\n"
"// <char>	::=	any non metacharacter | \"\\\" metacharacter\n"
"def private re_char (expr : string; offset:int) : MaybeReNode\n"
"    trace(\"re_char\",offset)\n"
"    if eos(expr,offset)\n"
"        return nada()\n"
"    let ch = at(expr,offset)\n"
"    if ch == '\\\\'\n"
"        let ech = at(expr,offset+1)\n"
"        if ech==0\n"
"            note(\"syntax error, expecting meta\", offset+1)\n"
"            return nada()\n"
"        if is_set_character(ech)\n"
"            var cset : CharSet\n"
"            set_meta(cset,ech)\n"
"            return maybe(new [[ReNode op=ReOp Set, cset=cset, at=range(offset,of"
"fset+2)]])\n"
"        return maybe(new [[ReNode op=ReOp Char, text=to_char(ech), textLen=1, at"
"=range(offset,offset+2)]])\n"
"    elif is_meta_character(ch)\n"
"        return nada()\n"
"    return maybe(new [[ReNode op=ReOp Char, text=to_char(ch), textLen=1, at=rang"
"e(offset,offset+1)]])\n"
"\n"
"// <set-items>	::=	<set-item> | <set-item> <set-items>\n"
"// <set-item>	::=	<range> | <char>\n"
"// <range>	::=	<char> \"-\" <char>\n"
"// <char>	::=	any non metacharacter | \"\\\" metacharacter\n"
"def private re_set_items(expr:string; offset:int) : MaybeReNode\n"
"    trace(\"re_set_items\",offset)\n"
"    if eos(expr,offset)\n"
"        return nada()\n"
"    var cset : CharSet\n"
"    var iofs = offset\n"
"    while !eos(expr,iofs)\n"
"        let ch = at(expr,iofs)\n"
"        if ch == ']'\n"
"            note(\"set - break - ]\",iofs)\n"
"            break\n"
"        elif ch=='\\\\'\n"
"            let che = at(expr,iofs+1)\n"
"            if che==0\n"
"                note(\"syntax error, expecting meta\", iofs)\n"
"                return nada()\n"
"            set_meta(cset,che)\n"
"            note(\"set - meta\",iofs)\n"
"            iofs += 2\n"
"        elif at(expr,iofs+1)=='-' && at(expr,iofs+2)!=']'\n"
"            let che = at(expr,iofs+2)\n"
"            if che==0\n"
"                note(\"syntax error, expecting range\", iofs+1)\n"
"                return nada()\n"
"            elif ch > che\n"
"                note(\"syntax error, character range out of order\", iofs)\n"
"                return nada()\n"
"            set_or_range(cset,range(ch,che))\n"
"            note(\"set - range\",iofs)\n"
"            iofs += 3\n"
"        else\n"
"            set_or_char(cset,ch)\n"
"            note(\"set - character\",iofs)\n"
"            iofs += 1\n"
"    return maybe(new [[ReNode op=ReOp Set, cset=cset, at=range(offset,iofs)]])\n"
"\n"
"// <negative-set>	::=	\"[^\" <set-items> \"]\"\n"
"// <positive-set>	::=	\"[\" <set-items> \"]\"\n"
"// <set>	::=	<positive-set> | <negative-set>\n"
"def private re_set(expr:string; offset:int) : MaybeReNode\n"
"    trace(\"re_set\",offset)\n"
"    if eos(expr,offset)\n"
"        return nada()\n"
"    if at(expr,offset)!='['\n"
"        return nada()\n"
"    var negative = false\n"
"    if at(expr,offset+1)=='^'\n"
"        negative = true\n"
"    var oset = re_set_items(expr,negative ? offset+2 : offset+1)\n"
"    if oset is nothing\n"
"        return nada()\n"
"    if at(expr,next(oset)) != ']'\n"
"        delete oset\n"
"        return nada()\n"
"    var oval = oset as value\n"
"    oval.at.x = offset\n"
"    oval.at.y ++\n"
"    oval.op = ReOp Set\n"
"    if negative\n"
"        set_negative(oval.cset)\n"
"    trace_value(oval)\n"
"    return oset\n"
"\n"
"// <any>	::=	\".\"\n"
"def private re_any(expr:string; offset:int) : MaybeReNode\n"
"    trace(\"re_any\",offset)\n"
"    if eos(expr,offset)\n"
"        return nada()\n"
"    if at(expr,offset)=='.'\n"
"        return maybe(new [[ReNode op=ReOp Any, at=range(offset,offset+1)]])\n"
"    return nada()\n"
"\n"
"// <eos>	::=	\"$\"\n"
"def private re_eos(expr:string; offset:int) : MaybeReNode\n"
"    trace(\"re_eos\",offset)\n"
"    if eos(expr,offset)\n"
"        return nada()\n"
"    if at(expr,offset)=='$'\n"
"        return maybe(new [[ReNode op=ReOp Eos, at=range(offset,offset+1)]])\n"
"    return nada()\n"
"\n"
"// <group>	::=	\"(\" <RE> \")\"\n"
"def private re_group(expr:string; offset:int) : MaybeReNode\n"
"    trace(\"re_group\",offset)\n"
"    if eos(expr,offset)\n"
"        return nada()\n"
"    if at(expr,offset)!='('\n"
"        return nada()\n"
"    var ore = re_re(expr,offset+1)\n"
"    if ore is nothing\n"
"        return nada()\n"
"    if at(expr,next(ore))!=')'\n"
"        delete ore\n"
"        return nada()\n"
"    return maybe(new [[ReNode op=ReOp Group, subexpr=ore as value, at=range(offs"
"et,next(ore)+1)]])\n"
"\n"
"// <elementary-RE>	::=	<group> | <any> | <eos> | <set> | <char>\n"
"def private re_elementary(expr:string; offset:int) : MaybeReNode\n"
"    trace(\"re_elementary\",offset)\n"
"    if eos(expr,offset)\n"
"        return nada()\n"
"    var ogr = re_group(expr,offset)\n"
"    if ogr is value\n"
"        return ogr\n"
"    var oany = re_any(expr,offset)\n"
"    if oany is value\n"
"        return oany\n"
"    var oeos = re_eos(expr,offset)\n"
"    if oeos is value\n"
"        return oeos\n"
"    var oset = re_set(expr,offset)\n"
"    if oset is value\n"
"        return oset\n"
"    var ochr = re_char(expr,offset)\n"
"    if ochr is value\n"
"        return ochr\n"
"    return nada()\n"
"\n"
"def private mk_concat(var left,right:ReNode?)\n"
"    if left == null\n"
"        return right\n"
"    elif left.op==ReOp Char && right.op==ReOp Char\n"
"        // mk_concat(char(x),char(y)) = char(xy)\n"
"        left.at.y = right.at.y\n"
"        left.text += right.text\n"
"        left.textLen += right.textLen\n"
"        unsafe\n"
"            delete right\n"
"        return left\n"
"    elif left.op==ReOp Concat && left.right.op==ReOp Char && right.op==ReOp Char"
"\n"
"        // mk_concat(concat(z,char(x)),char(y)) = concat(z,char(xy))\n"
"        var lor = left.right\n"
"        left.at.y = right.at.y\n"
"        lor.at.y = right.at.y\n"
"        lor.text += right.text\n"
"        lor.textLen += right.textLen\n"
"        unsafe\n"
"            delete right\n"
"        return left\n"
"    else\n"
"        return new [[ReNode op=ReOp Concat, left = left, right = right, at=range"
"(left.at.x,right.at.y)]]\n"
"\n"
"def private mk_union(var left,right:ReNode?) : ReNode?\n"
"    if left.op==ReOp Union\n"
"        left.at.y = right.at.y\n"
"        if right.op==ReOp Union                    // union(union(x),union(y)) ="
" union(xy)\n"
"            for x in right.all\n"
"                push(left.all,x)\n"
"            unsafe\n"
"                delete right\n"
"        else                                       // union(union(x),y) = union("
"xy)\n"
"            push(left.all,right)\n"
"        return left\n"
"    elif right.op==ReOp Union\n"
"        right.at.x = left.at.x\n"
"        push(right.all,left)                      // union(x,union(y)) = union(x"
"y)\n"
"        return right\n"
"    else\n"
"        return new [[ReNode op=ReOp Union, all <- [{ReNode? left; right}], at=ra"
"nge(left.at.x,right.at.y)]]\n"
"\n"
"// <RE>	::=	<union> | <simple-RE>\n"
"// <union>	::=	<RE> \"|\" <simple-RE>\n"
"// <simple-RE>	::=	<concatenation> | <basic-RE>\n"
"// <concatenation>	::=	<simple-RE> <basic-RE>\n"
"def private  re_re(expr:string; offset:int) : MaybeReNode\n"
"    trace(\"re_re\",offset)\n"
"    if eos(expr,offset)\n"
"        return nada()\n"
"    var cofs = offset\n"
"    var last : ReNode?\n"
"    while !eos(expr,cofs)\n"
"        if at(expr,cofs)=='|'\n"
"            if last == null\n"
"                note(\"syntax error, nada | union\", cofs)\n"
"                return nada()\n"
"            var oright = re_re(expr,cofs+1)\n"
"            if oright is nothing\n"
"                note(\"syntax error, re | nada\", cofs+1)\n"
"                return nada()\n"
"            last = mk_union(last,oright as value)\n"
"            cofs = last.at.y\n"
"        else\n"
"            var onext = re_basic(expr, cofs)\n"
"            if onext is nothing\n"
"                return last==null? nada() : maybe(last)\n"
"            last = mk_concat(last,onext as value)\n"
"            cofs = last.at.y\n"
"    return maybe(last)\n"
"\n"
"// <basic-RE>	::=	<star> | <plus> | <elementary-RE>\n"
"// <star>	::=	<elementary-RE> \"*\"\n"
"// <plus>	::=	<elementary-RE> \"+\"\n"
"def private re_basic(expr:string; offset:int) : MaybeReNode\n"
"    trace(\"re_basic\",offset)\n"
"    if eos(expr,offset)\n"
"        return nada()\n"
"    var oelem = re_elementary(expr,offset)\n"
"    if oelem is nothing\n"
"        return nada()\n"
"    let ch = at(expr,next(oelem))\n"
"    if ch=='*'\n"
"        return maybe(new [[ReNode op=ReOp Star, subexpr=oelem as value, at=range"
"(offset,next(oelem)+1)]])\n"
"    elif ch=='+'\n"
"        return maybe(new [[ReNode op=ReOp Plus, subexpr=oelem as value, at=range"
"(offset,next(oelem)+1)]])\n"
"    elif ch=='?'\n"
"        return maybe(new [[ReNode op=ReOp Question, subexpr=oelem as value, at=r"
"ange(offset,next(oelem)+1)]])\n"
"    return oelem\n"
"\n"
"def private re_parse ( expr:string ) : ReNode?\n"
"    var ore = re_re(expr, 0)\n"
"    if ore is nothing\n"
"        return null\n"
"    let at = next(ore)\n"
"    if at != length(expr)\n"
"        note(\"syntax error\",at)\n"
"        return null\n"
"    return ore as value\n"
"\n"
"def private visit_top_down ( var node:ReNode?; blk : block<(var n:ReNode?):void>"
" )\n"
"    invoke(blk,node)\n"
"    for x in node.all\n"
"        visit_top_down(x, blk)\n"
"    if node.subexpr!=null\n"
"        visit_top_down(node.subexpr, blk)\n"
"    if node.left!=null\n"
"        visit_top_down(node.left, blk)\n"
"    if node.right!=null\n"
"        visit_top_down(node.right, blk)\n"
"\n"
"def private re_assign_next ( var re:Regex )\n"
"    var id = 0\n"
"    visit_top_down(re.root) <| $ ( var node )\n"
"        node.id = id ++\n"
"        if node.op == ReOp Concat\n"
"            node.left.next = node.right\n"
"            node.right.next = node.next\n"
"        elif node.op == ReOp Group\n"
"            node.subexpr.next = node.next\n"
"        elif node.op == ReOp Union\n"
"            for sub in node.all\n"
"                sub.next = node.next\n"
"\n"
"def private re_assign_groups ( var re:Regex )\n"
"    push(re.groups, [[auto range(0),\"\"]])\n"
"    visit_top_down(re.root) <| $ ( var node )\n"
"        if node.op == ReOp Group\n"
"            let index = length(re.groups)\n"
"            node.index = index\n"
"            push(re.groups, [[auto range(0),\"{index}\"]])\n"
"\n"
"/*\n"
"    matching\n"
"*/\n"
"\n"
"def private re_assign_match_functions ( var re:Regex )\n"
"    visit_top_down(re.root) <| $ ( var node )\n"
"        if node.op==ReOp Char\n"
"            if node.textLen==1\n"
"                node.fun2 = @@re_match2_single_char\n"
"            else\n"
"                node.fun2 = @@re_match2_char\n"
"        elif node.op==ReOp Union\n"
"            node.fun2 = @@re_match2_union\n"
"        elif node.op==ReOp Set\n"
"            node.fun2 = @@re_match2_set\n"
"        elif node.op==ReOp Any\n"
"            node.fun2 = @@re_match2_any\n"
"        elif node.op==ReOp Eos\n"
"            node.fun2 = @@re_match2_eos\n"
"        elif node.op==ReOp Concat\n"
"            node.fun2 = @@re_match2_concat\n"
"        elif node.op==ReOp Plus\n"
"            if node.subexpr.op==ReOp Set\n"
"                node.cset = node.subexpr.cset\n"
"                node.fun2 = @@re_match2_plus_set\n"
"            else\n"
"                node.fun2 = @@re_match2_plus\n"
"            node.fun2 = @@re_match2_plus\n"
"        elif node.op==ReOp Star\n"
"            node.fun2 = @@re_match2_star\n"
"        elif node.op==ReOp Question\n"
"            node.fun2 = @@re_match2_question\n"
"        elif node.op==ReOp Group\n"
"            node.fun2 = @@re_match2_group\n"
"        else\n"
"            panic(\"unsupported {node.op}\")\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_single_char ( var regex:Regex; var node:ReNode?; str:uint8"
"? ) : uint8?\n"
"    if log_match_enabled\n"
"        print(\"match single char `{node.text}` {str}\\n\")\n"
"    unsafe\n"
"        if character_uat(node.text,0) != int(*str)\n"
"            return null\n"
"        var tail = str + 1\n"
"        node.tail = tail\n"
"        var node2 = node.next\n"
"        if node2!=null\n"
"            return invoke(node2.fun2,regex,node2,tail)\n"
"        else\n"
"            return tail\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_char ( var regex:Regex; var node:ReNode?; str:uint8? ) : u"
"int8?\n"
"    if log_match_enabled\n"
"        print(\"match char `{node.text}` {str}\\n\")\n"
"    unsafe\n"
"        if memcmp(reinterpret<uint8?> node.text,str,node.textLen) != 0\n"
"            return null\n"
"        var tail = str + node.textLen\n"
"        node.tail = tail\n"
"        var node2 = node.next\n"
"        if node2!=null\n"
"            if log_match_enabled\n"
"                print(\"NOP invoke\\n\")\n"
"            return invoke(node2.fun2,regex,node2,tail)\n"
"        else\n"
"            return tail\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_union ( var regex:Regex; var node:ReNode?; str:uint8? ) : "
"uint8?\n"
"    if log_match_enabled\n"
"        print(\"match union {str}\\n\")\n"
"    for sub in node.all\n"
"        let osub = invoke(sub.fun2,regex,sub,str)\n"
"        if osub != null\n"
"            node.tail = sub.tail\n"
"            return osub\n"
"    return null\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_set ( var regex:Regex; var node:ReNode?; str:uint8? ) : ui"
"nt8?\n"
"    if log_match_enabled\n"
"        print(\"match2 set {str}\\n\")\n"
"    if !is_char_in_set(int(*str),node.cset)\n"
"        return null\n"
"    unsafe\n"
"        var tail = str + 1\n"
"        node.tail = tail\n"
"        var node2 = node.next\n"
"        if node2!=null\n"
"            return invoke(node2.fun2,regex, node2, tail)\n"
"        else\n"
"            return tail\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_any ( var regex:Regex; var node:ReNode?; str:uint8? ) : ui"
"nt8?\n"
"    if log_match_enabled\n"
"        print(\"match2 any {str}\\n\")\n"
"    if int(*str)==0\n"
"        return null\n"
"    unsafe\n"
"        var tail = str + 1\n"
"        node.tail = tail\n"
"        var node2 = node.next\n"
"        if node2!=null\n"
"            return invoke(node2.fun2,regex, node2, tail)\n"
"        else\n"
"            return tail\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_concat ( var regex:Regex; var node:ReNode?; str:uint8? ) :"
" uint8?\n"
"    if log_match_enabled\n"
"        print(\"match2 concat {str}\\n\")\n"
"    var left = node.left\n"
"    let oleft = invoke(left.fun2, regex, left, str)\n"
"    if oleft == null\n"
"        return null\n"
"    node.tail = node.right.tail\n"
"    return oleft\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_eos ( var regex:Regex; var node:ReNode?; str:uint8? ) : ui"
"nt8?\n"
"    if log_match_enabled\n"
"        print(\"match eos {str}\\n\")\n"
"    if int(*str)!=0\n"
"        return null\n"
"    node.tail = str\n"
"    var node2 = node.next\n"
"    if node2!=null\n"
"        return invoke(node2.fun2,regex, node2, str)\n"
"    else\n"
"        return str\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_question ( var regex:Regex; var node:ReNode?; str:uint8? )"
" : uint8?\n"
"    if log_match_enabled\n"
"        print(\"match question {str}\\n\")\n"
"    var nsub = node.subexpr\n"
"    var tail = invoke(nsub.fun2,regex,nsub,str)\n"
"    if tail == null\n"
"        tail = str\n"
"    node.tail = tail\n"
"    var node2 = node.next\n"
"    if node2!=null\n"
"        return invoke(node2.fun2,regex,node2,tail)\n"
"    else\n"
"        return tail\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_plus ( var regex:Regex; var node:ReNode?; str:uint8? ) : u"
"int8?\n"
"    if log_match_enabled\n"
"        print(\"match2 plus {str}\\n\")\n"
"    var nsub = node.subexpr\n"
"    var osym = invoke(nsub.fun2,regex,nsub,str)\n"
"    if osym == null\n"
"        return null\n"
"    var ofs = osym\n"
"    var node2 = node.next\n"
"    if node2!=null\n"
"        while osym != null\n"
"            node.tail = osym\n"
"            var otail = invoke(node2.fun2,regex,node2,osym)\n"
"            if otail != null\n"
"                return otail\n"
"            osym = invoke(nsub.fun2,regex,nsub,osym)\n"
"        return null\n"
"    else\n"
"        while osym != null\n"
"            ofs = osym\n"
"            osym = invoke(nsub.fun2,regex,nsub,ofs)\n"
"        node.tail = ofs\n"
"        return ofs\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_plus_set ( var regex:Regex; var node:ReNode?; str:uint8? )"
" : uint8?\n"
"    if log_match_enabled\n"
"        print(\"match2 plus {str}\\n\")\n"
"    var nsub = node.subexpr\n"
"    if !is_char_in_set(int(*str),node.cset)\n"
"        return null\n"
"    unsafe\n"
"        var ofs = str + 1\n"
"        var osym = ofs\n"
"        var node2 = node.next\n"
"        if node2!=null\n"
"            while osym != null\n"
"                node.tail = osym\n"
"                var otail = invoke(node2.fun2,regex,node2,osym)\n"
"                if otail != null\n"
"                    return otail\n"
"                if !is_char_in_set(int(*osym),node.cset)\n"
"                    return null\n"
"                osym++\n"
"            return null\n"
"        else\n"
"            while osym != null\n"
"                ofs = osym\n"
"                if !is_char_in_set(int(*osym),node.cset)\n"
"                    break\n"
"                osym++\n"
"            node.tail = ofs\n"
"            return ofs\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_star ( var regex:Regex; var node:ReNode?; str:uint8? ) : u"
"int8?\n"
"    if log_match_enabled\n"
"        print(\"match2 plus {str}\\n\")\n"
"    var ofs = str\n"
"    var node2 = node.next\n"
"    var nsub = node.subexpr\n"
"    if node2!=null\n"
"        while ofs != null\n"
"            node.tail = ofs\n"
"            let oany = invoke(node2.fun2,regex,node2,ofs)\n"
"            if oany != null\n"
"                return oany\n"
"            ofs = invoke(nsub.fun2,regex,nsub,ofs)\n"
"        return null\n"
"    else\n"
"        var osym = ofs\n"
"        while osym != null\n"
"            ofs = osym\n"
"            osym = invoke(nsub.fun2,regex,nsub,ofs)\n"
"        node.tail = ofs\n"
"        return ofs\n"
"\n"
"[unsafe_deref]\n"
"def private re_match2_group ( var regex:Regex; var node:ReNode?; str:uint8? ) : "
"uint8?\n"
"    if log_match_enabled\n"
"        print(\"match2 group {str}\\n\")\n"
"    var nsub = node.subexpr\n"
"    let osub = invoke(nsub.fun2,regex,nsub,str)\n"
"    if osub==null\n"
"        return null\n"
"    regex.groups[node.index]._0 = range(int(str-regex.match),int(node.subexpr.ta"
"il-regex.match))\n"
"    return osub\n"
"\n"
"/*\n"
"    early out\n"
"*/\n"
"\n"
"def re_early_out ( var cset:CharSet; node:ReNode? ) : bool\n"
"    if node.op==ReOp Char\n"
"        set_or_char(cset,character_at(node.text,0))\n"
"        return false\n"
"    elif node.op==ReOp Set\n"
"        set_or_set(cset,node.cset)\n"
"        return false\n"
"    elif node.op==ReOp Any\n"
"        for x in cset\n"
"            x = 0xffffffffu\n"
"        return false\n"
"    elif node.op==ReOp Eos\n"
"        return false\n"
"    elif node.op==ReOp Group\n"
"        return re_early_out(cset,node.subexpr)\n"
"    elif node.op==ReOp Plus\n"
"        return re_early_out(cset,node.subexpr)\n"
"    elif node.op==ReOp Star\n"
"        re_early_out(cset,node.subexpr)\n"
"        return true\n"
"    elif node.op==ReOp Question\n"
"        re_early_out(cset,node.subexpr)\n"
"        return true\n"
"    elif node.op==ReOp Concat\n"
"        let left = re_early_out(cset,node.left)\n"
"        return left ? re_early_out(cset,node.right) : false\n"
"    elif node.op==ReOp Union\n"
"        var any = false\n"
"        for sub in node.all\n"
"            any = re_early_out(cset,sub) || any\n"
"        return any\n"
"    else\n"
"        panic(\"unsupported operation\")\n"
"        return false\n"
"\n"
"/*\n"
"    top level API\n"
"*/\n"
"\n"
"def is_valid(var re:Regex)\n"
"    return re.root != null\n"
"\n"
"def regex_compile( var re:Regex; expr:string ) : bool\n"
"    re.root = re_parse(expr)\n"
"    if re.root != null\n"
"        re_assign_next(re)\n"
"        re_assign_groups(re)\n"
"        re_assign_match_functions(re)\n"
"        re_early_out(re.earlyOut, re.root)\n"
"        re.canEarlyOut = !is_set_empty(re.earlyOut)\n"
"    return re.root != null\n"
"\n"
"def regex_compile ( expr : string )\n"
"    var re:Regex\n"
"    if !regex_compile(re,expr)\n"
"        panic(\"regular expression {expr} did not compile\")\n"
"    return <- re\n"
"\n"
"def regex_compile ( var re:Regex )\n"
"    if re.root != null\n"
"        re_assign_next(re)\n"
"        re_assign_match_functions(re)\n"
"    return <- re\n"
"\n"
"def regex_match ( var regex:Regex; str:string; offset:int=0 ) : int\n"
"    if empty(str)\n"
"        return -1\n"
"    if log_match_enabled\n"
"        print(\"matching with `{str}` at {offset}\\n\")\n"
"    unsafe\n"
"        regex.match = reinterpret<uint8?> str\n"
"        let mptr = invoke(regex.root.fun2,regex,regex.root,regex.match)\n"
"        if mptr == null\n"
"            return -1\n"
"        return int(mptr-regex.match)\n"
"\n"
"def regex_group ( regex:Regex; index:int; match:string )\n"
"    let sub_range = regex.groups[index]._0\n"
"    return slice(match, sub_range.x, sub_range.y)\n"
"\n"
"[unsafe_deref]\n"
"def regex_foreach ( var regex:Regex; str:string; blk : block<(at:range):bool> )\n"
"    if empty(str)\n"
"        return\n"
"    unsafe\n"
"        regex.match = reinterpret<uint8?> str\n"
"        var root = regex.root\n"
"        var pstr = reinterpret<uint8?> str\n"
"        var cstr = pstr\n"
"        if regex.canEarlyOut\n"
"            // lets try if it helps\n"
"            while true\n"
"                let Ch = int(*cstr)\n"
"                if Ch==0\n"
"                    break\n"
"                if is_char_in_set(Ch,regex.earlyOut)\n"
"                    let om = invoke(root.fun2,regex,root,cstr)\n"
"                    if om != null\n"
"                        if !invoke(blk,range(int(cstr-pstr),int(om-pstr)))\n"
"                            break\n"
"                        cstr = om\n"
"                    else\n"
"                        cstr++\n"
"                else\n"
"                    cstr++\n"
"        else\n"
"            while int(*cstr) != 0\n"
"                let om = invoke(root.fun2,regex,root,cstr)\n"
"                if om != null\n"
"                    if !invoke(blk,range(int(cstr-pstr),int(om-pstr)))\n"
"                        break\n"
"                    cstr = om\n"
"                else\n"
"                    cstr ++\n"
"\n"
"/*\n"
"    printer\n"
"*/\n"
"\n"
"def regex_debug ( regex:Regex )\n"
"    debug_re(regex.root,1)\n"
"    print(\"\\n\")\n"
"    if regex.canEarlyOut\n"
"        print(\"early out: \")\n"
"        debug_set(regex.earlyOut)\n"
"        print(\"\\n\")\n"
"    if length(regex.groups) != 0\n"
"        print(\"groups:\")\n"
"        for g in regex.groups\n"
"            print(\"\\t{g._1}\\n\")\n"
"\n"
"def debug_set(cset:CharSet)\n"
"    for x in range(256)\n"
"        if (cset[x>>5] & uint(1<<(x & 31))) != 0u\n"
"            if x>=32 && x<=127\n"
"                print(\"{to_char(x)}\")\n"
"            else\n"
"                print(\"\\\\{x}\")\n"
"\n"
"def private debug_re ( node: ReNode?; tab:int )\n"
"    print(\"(\")\n"
"    if node != null\n"
"        print(\"#{node.id}\")\n"
"        if node.next!=null\n"
"            print(\"->{node.next.id}\")\n"
"        else\n"
"            print(\"->!\")\n"
"        print(\" \")\n"
"    if node==null\n"
"        print(\"null)\")\n"
"    elif node.op==ReOp Char\n"
"        print(\"Char `{node.text}`)\")\n"
"    elif node.op==ReOp Set\n"
"        print(\"Set \")\n"
"        debug_set(node.cset)\n"
"        print(\")\")\n"
"    elif node.op==ReOp Any\n"
"        print(\"Any)\")\n"
"    elif node.op==ReOp Eos\n"
"        print(\"Eos)\")\n"
"    elif node.op==ReOp Group\n"
"        print(\"Group \")\n"
"        debug_re(node.subexpr,tab+1)\n"
"        print(\")\")\n"
"    elif node.op==ReOp Plus\n"
"        print(\"Plus \")\n"
"        debug_re(node.subexpr,tab)\n"
"        print(\")\")\n"
"    elif node.op==ReOp Star\n"
"        print(\"Star \")\n"
"        debug_re(node.subexpr,tab)\n"
"        print(\")\")\n"
"    elif node.op==ReOp Question\n"
"        print(\"Question \")\n"
"        debug_re(node.subexpr,tab)\n"
"        print(\")\")\n"
"    elif node.op==ReOp Concat\n"
"        print(\"Contact\")\n"
"        print(\"\\n{repeat(\"\\t\",tab)}\")\n"
"        debug_re(node.left,tab+1)\n"
"        print(\"\\n{repeat(\"\\t\",tab)}\")\n"
"        debug_re(node.right,tab+1)\n"
"        print(\"\\n{repeat(\"\\t\",tab-1)})\")\n"
"    elif node.op==ReOp Union\n"
"        print(\"Union\\n\")\n"
"        for sub in node.all\n"
"            print(\"{repeat(\"\\t\",tab)}\")\n"
"            debug_re(sub,tab+1)\n"
"            print(\"\\n\")\n"
"        print(\"{repeat(\"\\t\",tab-1)})\")\n"
"    else\n"
"        panic(\"unsupported op\")\n"
