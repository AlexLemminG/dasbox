//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options indenting = 4\n"
"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options no_aot\n"
"\n"
"module decs_boost shared private\n"
"\n"
"require daslib/decs public\n"
"\n"
"require daslib/ast_boost\n"
"require daslib/templates_boost\n"
"require daslib/strings_boost\n"
"\n"
"\n"
"/*\n"
"from:\n"
"    query ( ) <| $ ( pos:float3&; vel:float3; col:uint=0x12345678 )\n"
"        pos += vel\n"
"to:\n"
"    var erq <- [[EcsRequest req <- [[string \"pos\"; \"vel\"]] ]]\n"
"    erq |> for_each_archetype <| $ ( arch )\n"
"        for pos, vel in get(arch,\"pos\",type<float3>), get_ro(arch,\"vel\",type<flo"
"at3>), get_default_ro(arch,\"col\",0x12345678)\n"
"            tag\n"
"*/\n"
"\n"
"[block_macro(name=\"decs_require\")]\n"
"class DecsReq : AstFunctionAnnotation {}\n"
"\n"
"[block_macro(name=\"decs_require_not\")]\n"
"class DecsReqN : AstFunctionAnnotation {}\n"
"\n"
"[call_macro(name=\"query\")]\n"
"class ApplyMacro : AstCallMacro\n"
"    def override visit ( prog:ProgramPtr; mod:Module?; var expr:smart_ptr<ExprCa"
"llMacro> ) : ExpressionPtr\n"
"        if length(expr.arguments)!=1 || !(expr.arguments[0] is ExprMakeBlock)\n"
"            macro_error(prog,expr.at,\"expecting query($(block_with_arguments))\")"
"\n"
"            return [[ExpressionPtr]]\n"
"        let mblk = expr.arguments[0] as ExprMakeBlock\n"
"        let qblk = mblk._block as ExprBlock\n"
"        if length(qblk.arguments)==0\n"
"            macro_error(prog,expr.at,\"expecting query($(block_with_arguments)), "
"arguments are missing\")\n"
"            return [[ExpressionPtr]]\n"
"        let prefix = \"__{expr.at.line}_desc\"\n"
"        let erq_name = \"{prefix}_erq\"\n"
"        let arch_name = \"{prefix}_arch\"\n"
"        var req <- [[EcsRequest req<- [{for a in qblk.arguments; string(a.name);"
" where a.init==null}]]]\n"
"        for aa in qblk.annotations\n"
"            let isreq = eq(aa.annotation.name,\"decs_require\")\n"
"            let isreqn = eq(aa.annotation.name,\"decs_require_not\")\n"
"            if isreq || isreqn\n"
"                for ab in aa.arguments\n"
"                    if ab.basicType==Type tBool && ab.bValue\n"
"                        (isreq ? req.req : req.reqn) |> push(string(ab.name))\n"
"        compile_request(req)\n"
"        let vreq = verify_request(req)\n"
"        if !vreq.ok\n"
"            macro_error(prog,expr.at,\"incorrect query, {vreq.error}\")\n"
"            return [[ExpressionPtr]]\n"
"        var qblock <- quote() <|\n"
"            tag_req\n"
"            tag_erq |> for_each_archetype <| $ ( tag_arch )\n"
"                tag_loop\n"
"        var ereq <- new [[ExprLet() at=expr.at]]\n"
"        ereq.variables |> emplace_new <| new [[Variable() at=expr.at,\n"
"                name:=erq_name,\n"
"                _type <- new [[TypeDecl() at=expr.at, baseType=Type autoinfer]],"
"\n"
"                init <- convert_to_expression(req, expr.at),\n"
"                flags = VariableFlags init_via_move\n"
"            ]]\n"
"        var qloop <- new [[ExprFor() at=qblk.at, visibility=qblk.at]]\n"
"        qloop.iterators |> resize ( length(qblk.arguments) )\n"
"        for i,a in qloop.iterators, qblk.arguments\n"
"            i := a.name\n"
"            qloop.iteratorsAt |> push(a.at)\n"
"            var ftype <- clone_type(a._type)\n"
"            ftype.flags &= ~ TypeDeclFlags constant\n"
"            ftype.flags &= ~ TypeDeclFlags ref\n"
"            var getter = \"get_ro\"\n"
"            if a.init != null\n"
"                if a._type.flags.ref || !a._type.flags.constant\n"
"                    macro_error(prog,expr.at,\"argument {a.name} has default valu"
"e, it can't be & or var\")\n"
"                    return [[ExpressionPtr]]\n"
"                getter = \"get_default_ro\"\n"
"            elif a._type.flags.ref\n"
"                if a._type.flags.constant\n"
"                    macro_error(prog,expr.at,\"argument {a.name} is both & and co"
"nstant\")\n"
"                    return [[ExpressionPtr]]\n"
"                getter = \"get\"\n"
"            var cget <- new [[ExprCall() name:=getter, at=a.at]]\n"
"            cget.arguments |> emplace_new <| new [[ExprVar() at=a.at, name:=arch"
"_name]]\n"
"            cget.arguments |> emplace_new <| new [[ExprConstString() at=a.at, va"
"lue:=a.name]]\n"
"            if getter==\"get_default_ro\"\n"
"                cget.arguments |> emplace_new <| clone_expression(a.init)\n"
"            else\n"
"                cget.arguments |> emplace_new <| new [[ExprTypeDecl() at=a.at, t"
"ypeexpr<-ftype]]\n"
"            qloop.sources |> emplace(cget)\n"
"        var qlbody <- new [[ExprBlock() at=qblk.at]]\n"
"        for l in qblk.list\n"
"            qlbody.list |> emplace_new <| clone_expression(l)\n"
"        for fl in qblk.finalList\n"
"            qlbody.finalList |> emplace_new <| clone_expression(fl)\n"
"        qloop.body <- qlbody\n"
"        apply_template(expr.at, qblock) <| $ ( rules )\n"
"            rules |> renameVariable(\"tag_erq\") <| erq_name\n"
"            rules |> replaceBlockArgument(\"tag_arch\") <| arch_name\n"
"            rules |> replaceVariable(\"tag_req_array\") <| convert_to_expression(r"
"eq, expr.at)\n"
"            rules |> replaceVariable(\"tag_req\") <| ereq\n"
"            rules |> replaceVariable(\"tag_loop\") <| qloop\n"
"        var qres <- move_unquote_block(qblock)\n"
"        (qres as ExprBlock).blockFlags ^= ExprBlockFlags isClosure\n"
"        return <- qres\n"
