//
// AUTO-GENERATED FILE - DO NOT EDIT!!
//

"options indenting = 4\n"
"options no_unused_block_arguments = false\n"
"options no_unused_function_arguments = false\n"
"options no_aot\n"
"\n"
"module decs_boost shared private\n"
"\n"
"require daslib/decs public\n"
"\n"
"require daslib/ast_boost\n"
"require daslib/templates_boost\n"
"require daslib/strings_boost\n"
"\n"
"/*\n"
"from:\n"
"    query ( ) <| $ ( pos:float3&; vel:float3; col:uint=0x12345678 )\n"
"        pos += vel\n"
"to:\n"
"    for_each_archetype ( ERQ_HASH, @@ => [[EcsRequest req <- [[string \"pos\"; \"ve"
"l\"]] ]] ) <| $ ( arch )\n"
"        for pos, vel in get(arch,\"pos\",type<float3>), get_ro(arch,\"vel\",type<flo"
"at3>), get_default_ro(arch,\"col\",0x12345678)\n"
"            tag\n"
"*/\n"
"\n"
"[block_macro(name=\"decs_require\")]\n"
"class DecsReq : AstFunctionAnnotation {}\n"
"\n"
"[block_macro(name=\"decs_require_not\")]\n"
"class DecsReqN : AstFunctionAnnotation {}\n"
"\n"
"[structure_macro(name=\"decs_template\")]\n"
"class DecsTemplate : AstStructureAnnotation {}\n"
"\n"
"variant ItCheck\n"
"    yes : string\n"
"    no  : bool\n"
"\n"
"def private decs_prefix ( arg:AnnotationArgumentList )\n"
"    var p = find_arg ( \"prefix\", arg)\n"
"    if p is tString\n"
"        return [[ItCheck yes=p as tString]]\n"
"    elif p is tBool\n"
"        return [[ItCheck yes=\"\"]]\n"
"    else\n"
"        return [[ItCheck no=true]]\n"
"\n"
"def private is_decs_template ( v:VariablePtr )\n"
"    if v._type.baseType != Type tStructure\n"
"        return [[ItCheck no=true]]\n"
"    var p = v.annotation |> decs_prefix\n"
"    if p is no\n"
"        for ann in v._type.structType.annotations\n"
"            if eq(ann.annotation.name,\"decs_template\")\n"
"                p = ann.arguments |> decs_prefix\n"
"                return p is yes ? p : [[ItCheck yes=\"{v._type.structType.name}_\""
"]]\n"
"    return p\n"
"\n"
"def private append_iterator ( prog:ProgramPtr; arch_name:string; var qloop:smart"
"_ptr<ExprFor>; a; prefix:string; const_parent : bool = false )\n"
"    let qli = length(qloop.iterators)\n"
"    qloop.iterators |> resize( qli + 1 )\n"
"    qloop.iterators[qli] := \"{prefix}{a.name}\"\n"
"    qloop.iteratorsAt |> push(a.at)\n"
"    var ftype <- clone_type(a._type)\n"
"    ftype.flags &= ~ TypeDeclFlags constant\n"
"    ftype.flags &= ~ TypeDeclFlags ref\n"
"    var getter = \"get_ro\"\n"
"    if typeinfo(stripped_typename a)==\"ast::FieldDeclaration\"\n"
"        if a.init != null\n"
"            getter = \"get_default_ro\"\n"
"        elif !const_parent\n"
"            getter = \"get\"\n"
"    else\n"
"        if a.init != null\n"
"            if a._type.flags.ref || !a._type.flags.constant\n"
"                macro_error(prog,qloop.at,\"argument {a.name} has default value, "
"it can't be & or var\")\n"
"                return false\n"
"            getter = \"get_default_ro\"\n"
"        elif a._type.isRef\n"
"            if a._type.flags.constant\n"
"                macro_error(prog,qloop.at,\"argument {a.name} is both & and const"
"ant\")\n"
"                return false\n"
"            getter = \"get\"\n"
"    var cget <- new [[ExprCall() name:=getter, at=a.at]]\n"
"    cget.arguments |> emplace_new <| new [[ExprVar() at=a.at, name:=arch_name]]\n"
"    cget.arguments |> emplace_new <| new [[ExprConstString() at=a.at, value:=a.n"
"ame]]\n"
"    if getter==\"get_default_ro\"\n"
"        cget.arguments |> emplace_new <| clone_expression(a.init)\n"
"    else\n"
"        cget.arguments |> emplace_new <| new [[ExprTypeDecl() at=a.at, typeexpr<"
"-ftype]]\n"
"    qloop.sources |> emplace(cget)\n"
"    return true\n"
"\n"
"[call_macro(name=\"query\")]\n"
"class ApplyMacro : AstCallMacro\n"
"    def override visit ( prog:ProgramPtr; mod:Module?; var expr:smart_ptr<ExprCa"
"llMacro> ) : ExpressionPtr\n"
"        if length(expr.arguments)!=1 || !(expr.arguments[0] is ExprMakeBlock)\n"
"            macro_error(prog,expr.at,\"expecting query($(block_with_arguments))\")"
"\n"
"            return [[ExpressionPtr]]\n"
"        let mblk = expr.arguments[0] as ExprMakeBlock\n"
"        let qblk = mblk._block as ExprBlock\n"
"        if length(qblk.arguments)==0\n"
"            macro_error(prog,expr.at,\"expecting query($(block_with_arguments)), "
"arguments are missing\")\n"
"            return [[ExpressionPtr]]\n"
"        let prefix = \"__{expr.at.line}_desc\"\n"
"        let arch_name = \"{prefix}_arch\"\n"
"        var req : EcsRequest\n"
"        for a in qblk.arguments\n"
"            if a.init==null\n"
"                let detp = a |> is_decs_template\n"
"                if detp is yes\n"
"                    for f in a._type.structType.fields\n"
"                        if f.init == null\n"
"                            req.req |> push(\"{detp as yes}{f.name}\")\n"
"                else\n"
"                    req.req |> push(string(a.name))\n"
"        for aa in qblk.annotations\n"
"            let isreq = eq(aa.annotation.name,\"decs_require\")\n"
"            let isreqn = eq(aa.annotation.name,\"decs_require_not\")\n"
"            if isreq || isreqn\n"
"                for ab in aa.arguments\n"
"                    if ab.basicType==Type tBool && ab.bValue\n"
"                        (isreq ? req.req : req.reqn) |> push(string(ab.name))\n"
"        compile_request(req)\n"
"        let vreq = verify_request(req)\n"
"        if !vreq.ok\n"
"            macro_error(prog,expr.at,\"incorrect query, {vreq.error}\")\n"
"            return [[ExpressionPtr]]\n"
"        var qblock <- quote() <|\n"
"            for_each_archetype (tag_req, tag_erq) <| $ ( tag_arch )\n"
"                tag_loop\n"
"        // @@ => [[EcsQuery ...]]\n"
"        var erq_blk <- new [[ExprBlock() at=expr.at,\n"
"            returnType <- new [[TypeDecl() at=expr.at, baseType=Type autoinfer]]"
",\n"
"            blockFlags = ExprBlockFlags isClosure\n"
"        ]]\n"
"        erq_blk.list |> emplace_new <| new [[ExprReturn() at=expr.at,\n"
"            subexpr <- convert_to_expression(req, expr.at),\n"
"            returnFlags = ExprReturnFlags moveSemantics\n"
"        ]]\n"
"        var erq_fun <- new [[ExprMakeBlock() at=expr.at,\n"
"            mmFlags=ExprMakeBlockFlags isLocalFunction,\n"
"            _block <- erq_blk\n"
"        ]]\n"
"        // for s1, s2 ...\n"
"        var qloop <- new [[ExprFor() at=qblk.at, visibility=qblk.at]]\n"
"        var kaboom : array<tuple<string;string>>\n"
"        for a in qblk.arguments\n"
"            let detp = a |> is_decs_template\n"
"            if detp is yes\n"
"                kaboom |> push <| [[auto string(a.name),detp as yes]]\n"
"                for f in a._type.structType.fields\n"
"                    if !append_iterator(prog, arch_name, qloop, f, detp as yes, "
"a._type.flags.constant)\n"
"                        return [[ExpressionPtr]]\n"
"            else\n"
"                if !append_iterator(prog, arch_name, qloop, a, \"\")\n"
"                    return [[ExpressionPtr]]\n"
"        var qlbody <- new [[ExprBlock() at=qblk.at]]\n"
"        for l in qblk.list\n"
"            qlbody.list |> emplace_new <| clone_expression(l)\n"
"        for fl in qblk.finalList\n"
"            qlbody.finalList |> emplace_new <| clone_expression(fl)\n"
"        qloop.body <- qlbody\n"
"        apply_template(qloop) <| $ ( rules )\n"
"            for kb in kaboom\n"
"                rules |> kaboomVarField(kb._0,kb._1)\n"
"        apply_template(expr.at, qblock) <| $ ( rules )\n"
"            rules |> replaceVariable(\"tag_erq\") <| erq_fun\n"
"            rules |> replaceBlockArgument(\"tag_arch\") <| arch_name\n"
"            rules |> replaceVariable(\"tag_req\") <| new [[ExprConstUInt() at=expr"
".at, value=req.hash]]\n"
"            rules |> replaceVariable(\"tag_loop\") <| qloop\n"
"        var qres <- move_unquote_block(qblock)\n"
"        (qres as ExprBlock).blockFlags ^= ExprBlockFlags isClosure\n"
"        return <- qres\n"
